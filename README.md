# Краткое содержание "JAVA. Эффективное программирование", 3-е издание, Джошуа Блох

## Описание

Это мой конспект
книги ["JAVA. Эффективное программирование", 3-е издание, Джошуа Блох](https://www.williamspublishing.com/Books/978-5-6041394-4-8.html) (
сайт издательства).

[Репозиторий](https://github.com/jbloch/effective-java-3e-source-code/tree/master/src/effectivejava) с оригинальным
кодом из книги.

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

# 1. Содержание

- [1. Содержание](#1-содержание)
- [2. Создание и уничтожение объектов](#2-создание-и-уничтожение-объектов)
    - [2.1 Рассмотрите применение статических фабричных методов вместо конструкторов (Item 1)](#21-рассмотрите-применение-статических-фабричных-методов-вместо-конструкторов-item-1)
    - [2.2 При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель (Item 2)](#22-при-большом-количестве-параметров-конструктора-подумайте-о-проектном-шаблоне-строитель-item-2)
    - [2.3 Получайте синглтон с помощью закрытого конструктора или типа перечисления (Item 3)](#23-получайте-синглтон-с-помощью-закрытого-конструктора-или-типа-перечисления-item-3)
    - [2.4 Обеспечивайте неинстанцируемость с помощью закрытого конструктора (Item 4)](#24-обеспечивайте-неинстанцируемость-с-помощью-закрытого-конструктора-item-4)
    - [2.5 Предпочитайте внедрение зависимостей жестко прошитым ресурсам (Item 5)](#25-предпочитайте-внедрение-зависимостей-жестко-прошитым-ресурсам-item-5)
    - [2.6 Избегайте создание излишних объектов (Item 6)](#26-избегайте-создание-излишних-объектов-item-6)
    - [2.7 Избегайте устаревших ссылок (Item 7)](#27-избегайте-устаревших-ссылок-item-7)
    - [2.8 Избегайте финализаторов и очистителей (Item 8)](#28-избегайте-финализаторов-и-очистителей-item-8)
    - [2.9 Предпочитайте try-with-recurse использованию try-finally (Item 9)](#29-предпочитайте-try-with-recurse-использованию-try-finally-item-9)

# 2. Создание и уничтожение объектов

## 2.1 Рассмотрите применение статических фабричных методов вместо конструкторов (Item 1)

Плюсы:

- Они имеют имена
- Они не обязаны создавать новые объекты при каждом вызове
- Могу возвращать объект любого подтипа их возвращаемого типа
- Класс возращенного объекта может варьироваться от вызова к вызову в зависимости от входных параметров
- Класс возвращаемого объекта не обязан существовать во время разработки класса, содержащего метод.

Минусы:

- Классы без открытых или защищенных конструкторов не могу порождать подклассы
- Трудно отличить от других статических методов

## 2.2 При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель (Item 2)

- Если конструктор или статические фабрики имеет большое количество параметров(4+), то лучше рассмотреть шаблон
  Строитель при создании объекта.
- Код клиента проще для чтения и записи
- Безопаснее чем шаблон JavaBeans и может быть неизменяемым

_Реализация_:

```java

public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Обязательные параметры
        private final int servingSize;
        private final int servings;

        // Опциональные параметры со значением по умолчанию
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}
```

_Код клиента:_

```java

NutritionFacts cocaCola=new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();

```

## 2.3 Получайте синглтон с помощью закрытого конструктора или типа перечисления (Item 3)

_Синглтон с полем public final:_

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() { ...}

    public void singASong() { ...}
}

```

Плюсы:

- Из-за public поля API делает очевидным, что объект будет синглтом
- Простая реализация

_Синглтон со статической фабрикой:_

```java
    public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {...}

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void singASong() {...}
}

```

Плюсы:

- Можно изменить класс на не синглтон, не меняя его API
- Можно написать обобщенную фабрику синглтонов
- Можно использовать ссылку на метод, при использовании лямбды-выражения

Минусы этих реализаций:

- Можно вызвать конструктор с помощью рефлексии. Защита - добавить в конструктор генерацию исключения, при
  создании второго экземпляра.

Что бы сделать эти классы сериализуемым, необходимо пометить все поля transient и предоставить метод readResolve.

```java
class Item3 {
  private Object readResolve() {
    // Возвращает истенный объект
    return INSTANCE;
  }
}

```

_Синглтон-перечисление:_

```java

public enum Elvis() {
    INSTANCE;
		...

    public void singASong() {...}
}

```

Самый компактный способ, но не поддерживается наследование, только реализация интерфейса.

## 2.4 Обеспечивайте неинстанцируемость с помощью закрытого конструктора (Item 4)

Это подходит для классов, который имеет только статистические методы и статистические поля (Утильные классы).

Например:

- Группировка связанных методов над примитивами или массивами(java.util.Arrays)
- Группировка статистических методов и фабрики(java.util.Collections)
- Группировка методов в final-классе

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}

```

## 2.5 Предпочитайте внедрение зависимостей жестко прошитым ресурсам (Item 5)

Не стоит использовать класс синглтон или утильный(статистический), если они зависят от ресурсов(объектов), поведение
которых влияют на них. И не стоит предоставлять создание ресурсов этим классам.
Лучше предавать ресурсы или их фабрики для создания, конструктору (или статистической фабрике, или строителю). Этот
подход называется "Внедрение зависимостей", повышает гибкость, возможность повторного использования.

```java
public class SpellChecker {
    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
...
}
```

## 2.6 Избегайте создание излишних объектов (Item 6)

- **Повторное использование неизменяемых объектов(пулл)**

```java
String n = new String("bikini"); // Плохо
String p = "bikini"; // Хорошо
```

При повторном использовании, в первом случае будет создаваться новый объект, во втором использоваться старый из пула.

Использование статических фабричных методов для неизменяемого объекта.

```java
Boolean.valueOf(String)
```

- **Кэширование тяжеловесных объектов**

```java
class Item6 {
  public class RomanNumerals {
    // Можно повысить производительность
    static boolean isRomanNumeralSlow(String s) {
      return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }
  }
}
```

```java
// Оптимально
class Item6 {
  private static final Pattern ROMAN =
      Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

  static boolean isRomanNumeralFast(String s) {
    return ROMAN.matcher(s).matches();
  }
}

```

- **Предпочитайте примитивы классам оберткам и следите за непреднамеренной автоматической упаковкой**

- **Не следует кэшировать легковесные объекты их уничтожит сборщик мусора**
- **Избегайте создания собственного пула объектов. За исключением для тяжеловесных объектов, например подключение к базе
  данных**

## 2.7 Избегайте устаревших ссылок (Item 7)

**Лучший способ устранить устаревшие ссылки - выход переменной, содержащей
ссылку, из области видимости.**

Источники утечки памяти:

- **Класс управляет своей памятью.** В данном случае подойдет обнуление ссылки.

```java
class Item7 {
  public pop() {
    if (size == 0) throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;
    return result;
  }
}

```

Обнуление ссылки не норма, а исключение из правил - не нужно обнулять ссылку для каждого объекта.

- **Утечка памяти в кэше.**
  Для очищения ссылок из кэша, можно использовать следующие решения.
  Использовать WeakHashMap, но только если желаемое время жизни записей кэша определяется внешним ссылками на ключ, а не
  значением.
  Можно очищать в кэше старые записи: использовать фоновые потоки(ScheduledThreadPoolExecutor), удаление старых ссылок
  после вставки новой или LinkedHashMap с методом removeEldestEntry.
- **Приложения в режиме ожидания(слушателя) и другие обратные вызовы.** Если клиенты регистрируют обратные вызовы, но
  позже не отменяют эту регистрацию, они могут накапливаться. Можно хранить на них только слабые ссылки используя
  WeakHashMap.

Утечки памяти могут накапливаться в системе годами. И обнаружить их можно тщательного ревю кода или/и с использованием
профилировщика.

## 2.8 Избегайте финализаторов и очистителей (Item 8)

- Финализаторы непредсказуемы, часто опасны и в общем случае не нужны
- Очистители (java 9+) менее опасны, чем финализаторы, но столь же непредсказуемые, медленные и, в общем случае,
  ненужные
- С помощью финализатора или очистителя нельзя выполнять никакие операции, критичные по времени
- Не обновлять состояние объекта в зависимости от финализатора или очистителя
- Серьезные проблемы производительности при использовании финализаторов или очистителей
- Финализаторы являются серьезной проблемой безопасности: они открывают ваш класс для атак финализаторов
- Генерация исключения в конструкторпе должно быть достаточно для предотвращения существования объекта; однако при
  наличии финализатора это не так
- Для защиты классов, не являющихся финальными, от атак финализаторов напишите метод finalize, который не выполняет
  никаких действий
- Для класса, который инкапсулирует ресурсы, требующие освобождения, например файлы или потоки, лучше сделать его
  реализующий AutoCloseable. После этого его можно применять в конструкции try-with-recurse.

## 2.9 Предпочитайте try-with-recurse использованию try-finally (Item 9)

Предпочитайте try-with-recurse применению try-finally при работе с ресурсами, которые должны быть закрыты.
Результирующий код получается короче и понятнее, а исключения, которые он генерирует, — более полезными.

```java
class Item9 {
  static void copy(String src, String dst) throws IOException {
    try (InputStream in = new InputStream(src);
        OutputStream out = new FileOutputStream(dst)) {
      byte[] buf = new byte[BUFFER_SIZE];
      int n;
      while ((n = in.read(buf)) >= 0) {
        out.write(buf, 0, n);
      }
    }
  }
}

```

Оператор try-with-recurse облегчает написание корректного кода с использованием ресурсов, которые должны быть закрыты, что
практически невозможно с помощью try-finally.