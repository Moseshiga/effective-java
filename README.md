# Краткое содержание "JAVA. Эффективное программирование", 3-е издание, Джошуа Блох

## Описание

Это мой конспект
книги ["JAVA. Эффективное программирование", 3-е издание, Джошуа Блох](https://www.williamspublishing.com/Books/978-5-6041394-4-8.html) (
сайт издательства).

[Репозиторий](https://github.com/jbloch/effective-java-3e-source-code/tree/master/src/effectivejava) с оригинальным
кодом из книги.

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

Если Вы нашили опечатку/неточность пишите - разберемся.

[Связаться со мной](https://t.me/szachesov)

# 1. Содержание

- [1. Содержание](#1-содержание)
- [2. Создание и уничтожение объектов](#2-создание-и-уничтожение-объектов)
    - [2.1 Рассмотрите применение статических фабричных методов вместо конструкторов (Item 1)](#21-рассмотрите-применение-статических-фабричных-методов-вместо-конструкторов-item-1)
    - [2.2 При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель (Item 2)](#22-при-большом-количестве-параметров-конструктора-подумайте-о-проектном-шаблоне-строитель-item-2)
    - [2.3 Получайте синглтон с помощью закрытого конструктора или типа перечисления (Item 3)](#23-получайте-синглтон-с-помощью-закрытого-конструктора-или-типа-перечисления-item-3)
    - [2.4 Обеспечивайте неинстанцируемость с помощью закрытого конструктора (Item 4)](#24-обеспечивайте-неинстанцируемость-с-помощью-закрытого-конструктора-item-4)
    - [2.5 Предпочитайте внедрение зависимостей жестко прошитым ресурсам (Item 5)](#25-предпочитайте-внедрение-зависимостей-жестко-прошитым-ресурсам-item-5)
    - [2.6 Избегайте создание излишних объектов (Item 6)](#26-избегайте-создание-излишних-объектов-item-6)
    - [2.7 Избегайте устаревших ссылок (Item 7)](#27-избегайте-устаревших-ссылок-item-7)
    - [2.8 Избегайте финализаторов и очистителей (Item 8)](#28-избегайте-финализаторов-и-очистителей-item-8)
    - [2.9 Предпочитайте try-with-recurse использованию try-finally (Item 9)](#29-предпочитайте-try-with-recurse-использованию-try-finally-item-9)
- [3. Методы, общие для всех объектов](#3-методы-общие-для-всех-объектов)
    - [3.1 Перекрывая equals, соблюдайте общий контракт (Item 10)](#31-перекрывая-equals-соблюдайте-общий-контракт-item-10)
    - [3.2 Всегда при перекрытии equals перекрывайте hashCode (Item 11)](#32-всегда-при-перекрытии-equals-перекрывайте-hashcode-item-11)
    - [3.3 Всегда перекрывайте toString (Item 12)](#33-всегда-перекрывайте-tostring-item-12)
    - [3.4 Перекрывайте метод clone осторожно (Item 13)](#34-перекрывайте-метод-clone-осторожно-item-13)
    - [3.5 Подумайте о реализации Comparable (Item 14)](#35-подумайте-о-реализации-comparable-item-14)
- [4 Классы и интерфейсы](#4-классы-и-интерфейсы)
    - [4.1 Минимизируйте доступность классов и интерфейсов (Item 15)](#41-минимизируйте-доступность-классов-и-интерфейсов-item-15-)
    - [4.2 Используйте в открытых классах методы доступа, а не открытые поля (Item 16)](#42-используйте-в-открытых-классах-методы-доступа-а-не-открытые-поля-item-16)
    - [4.3 Минимизируйте изменяемость (Item 17)](#43-минимизируйте-изменяемость-item-17)
    - [4.4 Предпочитайте композицию наследованию (Item 18)](#44-предпочитайте-композицию-наследованию-item-18)
    - [4.5 Проектируйте и документируйте наследование, либо запрещайте его (Item 19)](#45-предпочитайте-композицию-наследованию-item-19-)
    - [4.6 Предпочитайте интерфейсы абстрактным классам (Item 20)](#46-предпочитайте-интерфейсы-абстрактным-классам-item-20)
    - [4.7 Проектируйте интерфейсы для потомков (Item 21)](#47-проектируйте-интерфейсы-для-потомков-item-21)
    - [4.8 Используйте интерфейсы только для определения типов (Item 22)](#48-используйте-интерфейсы-только-для-определения-типов-item-22)
    - [4.9 Предпочитайте иерархии классов дескрипторам классов (Item 23)](#49-предпочитайте-иерархии-классов-дескрипторам-классов-item-23)
    - [4.10 Предпочитайте статические классы-члены нестатическим (Item 24)](#410-предпочитайте-статические-классы-члены-нестатическим-item-24)
    - [4.11 Ограничивайтесь одним классом верхнего уровня на исходный файл (Item 25)](#411-ограничивайтесь-одним-классом-верхнего-уровня-на-исходный-файл-item-25)
- [5 Обобщенное программирование](#5-обобщенное-программирование)
    - [5.1 Не используйте несформированные типы (Item 26)](#51-не-используйте-несформированные-типы-item-26)
    - [5.2 Устраняйте предупреждение о непроверяемом коде (Item 27)](#52-устраняйте-предупреждение-о-непроверяемом-коде-item-27)
    - [5.3 Предпочитайте списки массивам (Item 28)](#53-предпочитайте-списки-массивам-item-28)
    - [5.4 Предпочитайте обобщенные типы (Item 29)](#54-предпочитайте-обобщенные-типы-item-29)
    - [5.5 Предпочитайте обобщенные методы (Item 30)](#55-предпочитайте-обобщенные-методы-item-30)
    - [5.6 Используйте ограниченные символы подстановки для повышения гибкости API (Item 31)](#56-используйте-ограниченные-символы-подстановки-для-повышения-гибкости-api-item-31)
    - [5.7 Аккуратно сочетайте обобщенные типы и переменное количество аргументов (Item 32)](#57-аккуратно-сочетайте-обобщенные-типы-и-переменное-количество-аргументов-item-32)
    - [5.8 Применяйте безопасные с точки зрения типов гетерогенные контейнеры (Item 33)](#58-применяйте-безопасные-с-точки-зрения-типов-гетерогенные-контейнеры-item-33)
- [6 Перечисления и аннотации](#6-перечисления-и-аннотации)
    - [6.1 Используйте перечисление вместо констант int (Item 34)](#61-используйте-перечисление-вместо-констант-int-item-34)
    - [6.2 Используйте поля экземпляра вместо порядковых значений (Item 35)](#62-используйте-поля-экземпляра-вместо-порядковых-значений-item-35)
    - [6.3 Используйте EnumSet вместо битовых полей (Item 36)](#63-используйте-enumset-вместо-битовых-полей-item-36)
    - [6.4 Используйте EnumMap вместо индексирования порядковыми номерами (Item 37)](#64-используйте-enummap-вместо-индексирования-порядковыми-номерами-item-37)
    - [6.5 Имитируйте расширяемые перечисления с помощью интерфейсов (Item 38)](#65-имитируйте-расширяемые-перечисления-с-помощью-интерфейсов-item-38)
    - [6.6 Предпочитайте аннотации схемам именования (Item 39)](#66-предпочитайте-аннотации-схемам-именования-item-39)
    - [6.7 Последовательно используйте аннотацию Override (Item 40)](#67-последовательно-используйте-аннотацию-override-item-40)
    - [6.8 Используйте интерфейсы-маркеры для определения типов (Item 41)](#68-используйте-интерфейсы-маркеры-для-определения-типов-item-41)
- [7 Лямбда-выражения и Stream API](#7-лямбда-выражения-и-stream-api)
    - [7.1 Предпочитайте лямбда-выражения анонимным классам (Item 42)](#71-предпочитайте-лямбда-выражения-анонимным-классам-item-42)
    - [7.2 Предпочитайте ссылки на методы лямбда-выражениям (Item 43)](#72-предпочитайте-ссылки-на-методы-лямбда-выражениям-item-43)
    - [7.3 Предпочитайте использовать стандартные функциональные интерфейсы (Item 44)](#73-предпочитайте-использовать-стандартные-функциональные-интерфейсы-item-44)
    - [7.4 Разумно используйте Stream API (Item 45)](#74-разумно-используйте-stream-api-item-45)
    - [7.5 Предпочитайте в потоках функции без побочных эффектов (Item 46)](#75-предпочитайте-в-потоках-функции-без-побочных-эффектов-item-46)
    - [7.6 Предпочитайте колекции потокам в качестве возвращаемых типов (Item 47)](#76-предпочитайте-колекции-потокам-в-качестве-возвращаемых-типов-item-47)
    - [7.7 Будьте внимательны при параллелизации потоков (Item 48)](#77-будьте-внимательны-при-параллелизации-потоков-item-48)
- [8 Методы](#8-методы)
    - [8.1 Проверяйте корректность параметров (Item 49)](#81-проверяйте-корректность-параметров-item-49)
    - [8.2 При необходимости создавайте защитные копии (Item 50)](#82-при-необходимости-создавайте-защитные-копии-item-50)
    - [8.3 Тщательно проектируйте сигнатуры методов (Item 51)](#83-тщательно-проектируйте-сигнатуры-методов-item-51)
    - [8.4 Перезагружайте методы разумно (Item 52)](#84-перезагружайте-методы-разумно-item-52)
    - [8.5 Используйте методы с переменным количеством аргументов с осторожностью (Item 53)](#85-используйте-методы-с-переменным-количеством-аргументов-с-осторожностью-item-53)
    - [8.6 Возвращайте пустые массивы и коллекции, а не null (Item 54)](#86-возвращайте-пустые-массивы-и-коллекции-а-не-null-item-54)
    - [8.7 Возвращайте Optional с осторожностью (Item 55)](#87-возвращайте-optional-с-осторожностью-item-55)
    - [8.8 Пишите документирующие комментарии для всех открытых элементов API (Item 56)](#88-пишите-документирующие-комментарии-для-всех-открытых-элементов-api-item-56)
- [9. Общие вопросы программирования](#9-общие-вопросы-программирования)
    - [9.1 Минимизируйте область видимости локальных переменных (Item 57)](#91-минимизируйте-область-видимости-локальных-переменных-item-57)
    - [9.2 Предпочитайте циклы for для коллекции традиционным циклам for (Item 58)](#92-предпочитайте-циклы-for-для-коллекции-традиционным-циклам-for-item-58)
    - [9.3 Изучите и используйте возможности библиотек (Item 59)](#93-изучите-и-используйте-возможности-бибилотек-item-59)
    - [9.4 Если вам нужны точные ответы, избегайте float и double (Item 60)](#94-если-вам-нужны-точные-ответы-избегайте-float-и-double-item-60)
    - [9.5 Предпочитайте примитивные типы упакованных примитивным типам (Item 61)](#95-предпочитайте-примитивные-типы-упакованных-примитивным-типам-item-61)
    - [9.6 Избегайте применения строк так, где уместнее другой тип (Item 62)](#96-избегайте-применения-строк-так-где-уместнее-другой-тип-item-62)
    - [9.7 Помните о проблемах производительности при конкатенации строк (Item 63)](#97-помните-о-проблемах-производительности-при-конкатенации-строк-item-63)
    - [9.8 Для ссылки на объекты используйте их интерфейсы (Item 64)](#98-для-ссылки-на-объекты-используйте-их-интерфейсы-item-64)
    - [9.9 Для ссылки на объекты используйте их интерфейсы (Item 65)](#99-для-ссылки-на-объекты-используйте-их-интерфейсы-item-65)

# 2. Создание и уничтожение объектов

## 2.1 Рассмотрите применение статических фабричных методов вместо конструкторов (Item 1)

Плюсы:

- Они имеют имена
- Они не обязаны создавать новые объекты при каждом вызове
- Могу возвращать объект любого подтипа их возвращаемого типа
- Класс возращенного объекта может варьироваться от вызова к вызову в зависимости от входных параметров
- Класс возвращаемого объекта не обязан существовать во время разработки класса, содержащего метод.

Минусы:

- Классы без открытых или защищенных конструкторов не могу порождать подклассы
- Трудно отличить от других статических методов

Распространенные статистические фабричные методы:

| **Название**                  | **Описание**                                                                                                 | **Пример**                                                   |
|-------------------------------|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------|
| **from**                      | преобразование типа                                                                                          | `Date d = Date.from(instant)`                                |
| **of**                        | метод агрегации                                                                                              | `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`        |
| **valueOf**                   | многословия альтернатива **from**, **of**                                                                    | `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)`   |
| **instance**, **getInstance** | возвращает экземпляр, описываемый параметрами, но о котором нельзя сказать, что имеет тоже значение          | `StackWalker luke = StackWalker.getInstance(options)`        |
| **create**, **newInstance**   | подобен **instance** или **getInstance**, но точно возвращает новый экземпляр                                | `Object newArray = Array.newInstance(classObject, arrayLen)` |
| **get**Type                   | подобен **getInstance**, но если фабричный метод находится в другом классе. Type - тип возвращаемого объекта | `FileStore fs = Files.getFileStore(path)`                    |
| **new**Type                   | подобен **newInstance**, но если фабричный метод находится в другом классе. Type - тип возвращаемого объекта | `BufferedReader br = Files.newBufferedReader(path)`          |
| type                          | краткая альтернатива **get**Type и **new**Type                                                               | `List<Complaint> litany = Collections.list(legacyLitany)`    |

## 2.2 При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель (Item 2)

- Если конструктор или статические фабрики имеет большое количество параметров(4+), то лучше рассмотреть шаблон
  Строитель при создании объекта.
- Код клиента проще для чтения и записи
- Безопаснее чем шаблон JavaBeans и может быть неизменяемым

_Реализация_:

```java

public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Обязательные параметры
        private final int servingSize;
        private final int servings;

        // Опциональные параметры со значением по умолчанию
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}
```

_Код клиента:_

```java

NutritionFacts cocaCola=new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();

```

## 2.3 Получайте синглтон с помощью закрытого конструктора или типа перечисления (Item 3)

_Синглтон с полем public final:_

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() { ...}

    public void singASong() { ...}
}

```

Плюсы:

- Из-за public поля API делает очевидным, что объект будет синглтом
- Простая реализация

_Синглтон со статической фабрикой:_

```java
    public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {...}

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void singASong() {...}
}

```

Плюсы:

- Можно изменить класс на не синглтон, не меняя его API
- Можно написать обобщенную фабрику синглтонов
- Можно использовать ссылку на метод, при использовании лямбды-выражения

Минусы этих реализаций:

- Можно вызвать конструктор с помощью рефлексии. Защита - добавить в конструктор генерацию исключения, при
  создании второго экземпляра.

Что бы сделать эти классы сериализуемым, необходимо пометить все поля transient и предоставить метод readResolve.

```java
class Item3 {
    private Object readResolve() {
        // Возвращает истенный объект
        return INSTANCE;
    }
}

```

_Синглтон-перечисление:_

```java

public enum Elvis() {
    INSTANCE;
		...

    public void singASong() {...}
}

```

Самый компактный способ, но не поддерживается наследование, только реализация интерфейса.

## 2.4 Обеспечивайте неинстанцируемость с помощью закрытого конструктора (Item 4)

Это подходит для классов, который имеет только статистические методы и статистические поля (Утильные классы).

Например:

- Группировка связанных методов над примитивами или массивами(java.util.Arrays)
- Группировка статистических методов и фабрики(java.util.Collections)
- Группировка методов в final-классе

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}

```

## 2.5 Предпочитайте внедрение зависимостей жестко прошитым ресурсам (Item 5)

Не стоит использовать класс синглтон или утильный(статистический), если они зависят от ресурсов(объектов), поведение
которых влияют на них. И не стоит предоставлять создание ресурсов этим классам.
Лучше предавать ресурсы или их фабрики для создания, конструктору (или статистической фабрике, или строителю). Этот
подход называется "Внедрение зависимостей", повышает гибкость, возможность повторного использования.

```java
public class SpellChecker {
    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
...
}
```

## 2.6 Избегайте создание излишних объектов (Item 6)

- **Повторное использование неизменяемых объектов(пулл)**

```java
String n=new String("bikini"); // Плохо
        String p="bikini"; // Хорошо
```

При повторном использовании, в первом случае будет создаваться новый объект, во втором использоваться старый из пула.

Использование статических фабричных методов для неизменяемого объекта.

```java
Boolean.valueOf(String)
```

- **Кэширование тяжеловесных объектов**

```java
class Item6 {
    public class RomanNumerals {
        // Можно повысить производительность
        static boolean isRomanNumeralSlow(String s) {
            return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
        }
    }
}
```

```java
// Оптимально
class Item6 {
    private static final Pattern ROMAN =
            Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralFast(String s) {
        return ROMAN.matcher(s).matches();
    }
}

```

- **Предпочитайте примитивы классам оберткам и следите за непреднамеренной автоматической упаковкой**

- **Не следует кэшировать легковесные объекты их уничтожит сборщик мусора**
- **Избегайте создания собственного пула объектов. За исключением для тяжеловесных объектов, например подключение к базе
  данных**

## 2.7 Избегайте устаревших ссылок (Item 7)

**Лучший способ устранить устаревшие ссылки - выход переменной, содержащей
ссылку, из области видимости.**

Источники утечки памяти:

- **Класс управляет своей памятью.** В данном случае подойдет обнуление ссылки.

```java
class Item7 {
    public pop() {
        if (size == 0) throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null;
        return result;
    }
}

```

Обнуление ссылки не норма, а исключение из правил - не нужно обнулять ссылку для каждого объекта.

- **Утечка памяти в кэше.**
  Для очищения ссылок из кэша, можно использовать следующие решения.
  Использовать WeakHashMap, но только если желаемое время жизни записей кэша определяется внешним ссылками на ключ, а не
  значением.
  Можно очищать в кэше старые записи: использовать фоновые потоки(ScheduledThreadPoolExecutor), удаление старых ссылок
  после вставки новой или LinkedHashMap с методом removeEldestEntry.
- **Приложения в режиме ожидания(слушателя) и другие обратные вызовы.** Если клиенты регистрируют обратные вызовы, но
  позже не отменяют эту регистрацию, они могут накапливаться. Можно хранить на них только слабые ссылки используя
  WeakHashMap.

Утечки памяти могут накапливаться в системе годами. И обнаружить их можно тщательного ревю кода или/и с использованием
профилировщика.

## 2.8 Избегайте финализаторов и очистителей (Item 8)

- Финализаторы непредсказуемы, часто опасны и в общем случае не нужны
- Очистители (java 9+) менее опасны, чем финализаторы, но столь же непредсказуемые, медленные и, в общем случае,
  ненужные
- С помощью финализатора или очистителя нельзя выполнять никакие операции, критичные по времени
- Не обновлять состояние объекта в зависимости от финализатора или очистителя
- Серьезные проблемы производительности при использовании финализаторов или очистителей
- Финализаторы являются серьезной проблемой безопасности: они открывают ваш класс для атак финализаторов
- Генерация исключения в конструкторе должно быть достаточно для предотвращения существования объекта; однако при
  наличии финализатора это не так
- Для защиты классов, не являющихся финальными, от атак финализаторов напишите метод finalize, который не выполняет
  никаких действий
- Для класса, который инкапсулирует ресурсы, требующие освобождения, например файлы или потоки, лучше сделать его
  реализующий AutoCloseable. После этого его можно применять в конструкции try-with-recurse.

## 2.9 Предпочитайте try-with-recurse использованию try-finally (Item 9)

Предпочитайте try-with-recurse применению try-finally при работе с ресурсами, которые должны быть закрыты.
Результирующий код получается короче и понятнее, а исключения, которые он генерирует, — более полезными.

```java
class Item9 {
    static void copy(String src, String dst) throws IOException {
        try (InputStream in = new InputStream(src);
             OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0) {
                out.write(buf, 0, n);
            }
        }
    }
}

```

Оператор try-with-recurse облегчает написание корректного кода с использованием ресурсов, которые должны быть закрыты,
что
практически невозможно с помощью try-finally.

# 3. Методы, общие для всех объектов

## 3.1 Перекрывая equals, соблюдайте общий контракт (Item 10)

Когда не следует перекрывать:

- Каждый экземпляр класса уникален по своей природе
- У класса нет необходимости в проверке "логической эквивалентности"
- Суперкласс уже переопределяет equals, и поведение суперкласса подходит для данного класса
- Класс является закрытым или закрытым на уровне пакета, и вы уверены, что его метод equals никогда не будте вызываться

Класс имеет смысл перекрывать equals, когда для него определено понятие логической эквивалентности(logical equality),
которая не совпадает с тождественностью объектов, а метод equals в суперклассе не перекрыт. Это происходит с классами
значениями(value class) - String, Integer и др.

Требования отношения эквивалентности:

- Рефлексивность: x.equals(x)==true
- Симметричность: x.equals(y)==y.equals(x)
- Транзитивность: x.equals(y)==y.equals(z)==z.equals(x)
- Непротиворечивость: x.equals(y)==x.equals(y)==x.equals(y)==...
- Отличный от null: x.equals(null)==false

Рецепт хорошего equals:

- Используйте оператор == для проверки того, что аргумент является ссылкой на данный объект
- Используйте оператор instanceof для проверки того, что аргумент имеет корректный тип
- Приводите аргумент к корректному типу
- Для каждого "важного" поля класса убедитесь, что значение этого поля в аргументе соответствует полю данного объекта

```java
class Item10 {
    @Override
    public boolean equals(Object o) {
        if (o == this) return true;

        if (!(o instanceof PhoneNumber)) return false;

        PhoneNumber pn = (PhoneNumber) o;
        return pn.lineNumber == lineNumber && pn.prefix == prefix && pn.areaCode == areaCode;
    }
}

```

Ещё предостережения:

- Всегда перекрывайте hashCode при перекрытии equals
- Не пытайтесь быть слишком умным
- Не подставляйте другой тип вместо Object в объявлении equals

## 3.2 Всегда при перекрытии equals перекрывайте hashCode (Item 11)

**Вы обязанный перекрывать hashCode в каждом классе, перекрывающем equals.**

Контракт hashCode:

- Для одно объекта, при многократном вызове hashCode должен всегда возвращать одно и то же целое число. При условии, что
  никакая информация, используемая при сравнении этого объекта с другими методом equals, не изменилась.
- Если два объекта равны по equals, то по hashCode тоже должны быть равны
- Если два объекта неравны по equals, то по hashCode могут быть равны или не равны. Но для оптимизации, лучше что бы
  были равны

Рецепт хорошего hashCode:

1. Объявить переменную int result и инициализировать её хеш-кодом для первого значащего поля объекта, описано в п. 2, а.
2. Для остальных значащих полей:

* Вычислите хеш-код типа int следующим образом:
    * Примитивный тип: Type.hashCode(f), Type - клас обертка для примитивного типа
    * Ссылочный тип: если метод equal перекрыт и рекурсивно вызывается при использовании, то и hashCode вызывать
      рекурсивно. Если требуется сложное сравнение, то вычислить "каноническое представление" и вызвать hashCode. Если
      null, то 0.
    * Массив: вычислить для каждого объекта рекурсивно hashCode и объединить, а как в след. пункте. Если нет значащих
      элементов, то значение 0. Если все значащиеся, то Arrays.hasCode.
* Объедините хеш-код, вычисленные в предыдущем пункте: result = 31 * result + с(предыдущий hashCode).

3. Верните result

```java
class Item11 {
    @Override
    public int hashCode() {
        int result = Short.hashCode(areaCode);
        result = 31 * result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        return result;
    }
}

```

И ещё:

- Не пытайтесь исключить значимые поля из вычисления хеш-кода для повышения производительности
- Не предоставляйте подробную спецификацию значения, возвращаемого hashCode, так, чтобы клиенты не могли от него
  зависеть; это позволит его изменить.

## 3.3 Всегда перекрывайте toString (Item 12)

Всегда перекрывайте метод toString в каждом инструктируемом классе, если только он не переопределен в суперклассе.

Предоставление хорошей реализации метода toString делает ваш класс гораздо более удобным в использовании, а использующею
его систему - более простой в отладке.

Чтобы представлять интерес на практике, метод toString должен возвращать всю полезную информацию, которая содержится в
объекте

Документируйте логину вывода toString, если даже не стандартизируете формат вывода.

Предоставляйте программный доступ ко всей информации в значении, возвращаемом методом toString

## 3.4 Перекрывайте метод clone осторожно (Item 13)

Класс, реализующий Cloneable, предоставляет надлежащим образом функционирующий открытый метод clone. Иначе при вызове
клон возвратится CloneNotSupportedException.

Неизменяемые классы никогда не должны предоставлять метод clone, потому что это будет просто поощрением излишнего
копирования.

Для неокончательного класса, без полей с изменяемыми объектами, необходимо перекрыть метод clone, в качестве
возвращаемого типа будет сам класс в котором он реализован. Метод clone будет вызывать super.clone.

```java
class Item13 {
    @Override
    public PhoneNumber clone() {
        try {
            return (PhoneNumber) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(); // Can't happen
        }
    }
}

```

Если класс имеет поля, которые ссылаются на изменяемые объекты, то нужно вызвать clone рекурсивно для изменяемых полей.
Иначе поля клона будут ссылаться на объекты, на которые ссылаются поля объекта оригинала.

```java
class Item13 {
    @Override
    public Stack clone() {
        try {
            Stack result = (Stack) super.clone();
            result.elements = elements.clone();
            return result;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

```

Архитектура Cloneable несовместима с нормальны использованием final-полей, ссылающихся на изменяемые объекты. Возможно
потребуется убрать final, что клонировать объект.

Метод clone никогда не должен вызывать перекрываемый метод для создаваемого клона.

Открытые методы clone должны опускать конструкцию throws, поскольку методы, не генерирующие проверяем исключения, более
просты в использовании.

При проектировании класса для наследования, он не должен реализовывать интерфейс Cloneable. Есть два варианта:
имитировать поведение Object, путем реализации корректного clone или как генерирующего исключение
CloneNotSupportedException.

Метод клонирования должен правильно быть синхронизирован.

Лучшие альтернативы для клонирования объектов:

1. Конструктор копирования

```java
public Yum(Yum yum);
```

2. Фабрика копий

```java
public static Yum newInstance(Yum yum);
```

Плюсы:

- Не полагается на сложный механизм создания объектов
- Не требует соблюдения слабо документированных соглашений
- Не конфликтует с использованием final-полей
- Не генерирует ненужные непроверяемые исключения
- Не требует преобразования объектов

Также данные подходы позволяют использовать для преобразования объектов

```java
new TreeMap<>(new HashMap<>());
```

## 3.5 Подумайте о реализации Comparable (Item 14)

Реализуя класс значения(value class), которое имеет упорядочение, обеспечивайте реализацию Comparable, чтобы его
экземпляры можно было легко сортировать, искать и использовать в коллекциях, основных на сравнениях.

Контракт метода compareTo:

- x.compareTo(y) == - (y.compareTo(x))
- если x.compareTo(y) > 0 && y.compareTo(z) > 0, тогда и x.compareTo(z) > 0
- если x.compareTo(y) == 0, тогда и x.compareTo(z) == y.compareTo(z)
- Рекомендуется, но не обязательно: (x.compareTo(y)==0) == (x.equals(y))

Если метод compareTo сталкивается с объектами разных типов, генерируйте исключение ClassCastException.

При сравнении значимых полей в compareTo следует избегать операторы **<** и **>**. Вместо этого использовать
статистические
методы compare классов оберток примитивных типов или методы конструирования компаратора в интерфейсе Comparator.

# 4 Классы и интерфейсы

## 4.1 Минимизируйте доступность классов и интерфейсов (Item 15)

Хорошо спроектированный модуль скрывает все детали реализации, четко отделяя API от реализации.

Делайте класс или член класса как можно более недоступным.

Классы и интерфейсы верхнего уровня могу иметь для уровня доступа: по-умолчанию и открытые.
Если класс или интерфейс верхнего уровня, доступный лишь в пределах пакета, используется только в одном классе, нужно
рассмотреть превращения его в закрытый статический класс, вложенный только в тот класс, в ктором он используется.

Если какой-либо метод перекрывает метод суперкласса, то в подклассе он не может иметь более ограниченный доступ, чем в
суперклассе.

Поля класса должны иметь уровень доступа private.
Поля константы могут быть открыты public static final. Но если константа ссылается на изменяемый объект, то поле
обладает недостатками не final поля.

Массив ненулевой длинный всегда изменяемый, ошибка если объявлен как public static final.

В Java 9+ появилось два неявных модификатора, как часть модульной системы. Открытые и защищенные члены открытых классов
в неэскортируемых пакетах дают два неявных уровня доступа, которые являются внутри модульными аналогами обычных открытых
и защищенных уровней. Данный модификаторы не так распространены и можно обойтись переупорядочиванием классов внутри
пакета.

## 4.2 Используйте в открытых классах методы доступа, а не открытые поля (Item 16)

Минусы открытых полей:

- Они лишены преимуществ инкапсуляции
- Нельзя изменить представление класса, не изменив его API
- Нельзя обеспечить выполнение инвариантов и предпринимать дополнительных действий при обращении к полю

Если класс доступен за пределами пакета, следует обеспечить методы доступа. Но если класс доступен в пределах пакета или
является закрытым вложенным классом, то никакого ущерба от предоставления доступа к его полям данных не будет.

## 4.3 Минимизируйте изменяемость (Item 17)

Неизменяемый класс - это класс, вся информация записывается в момент создания объекта и остается неизменной в течение
всего времени существования. Их проще проектировать, реализовывать и использовать. Они менее подвержены ошибкам и более
безопасны.

Как сделать класс незаменяемым:

1. Не проставлять методы, которые изменяют состояние объекта - методы установки(mutator).
2. Гарантируйте невозможность расширения класса. Добавление классу ключевого слова final, есть и другие способы.
3. Объявите все поля как final
4. Объявите все поля как private
5. Обеспечьте монопольный доступ ко всем изменяемым компонентам. Если класс имеет поля, ссылающиеся на изменяемые
   объекты, клиенты класса не должны получить ссылки на эти объекты. Не инициализируйте эти поля ссылками на объект,
   которые предоставляют клиент. Делайте защитные копии(Item) в конструктора, методах доступа и методах readObject(
   Item).

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    // Accessors with no corresponding mutators
    public double realPart() {
        return re;
    }

    public double imaginaryPart() {
        return im;
    }

    public Complex add(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex subtract(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    @Override
    public boolean equals(Object o) {
    }
}

```

Неизменяемые объекты просты. Они могут находиться только в одном состоянии - с котором был создан.

Неизменяемые объекты потокобезопасны и не нужна синхронизация.

Неизменяемые объекты можно использоваться совместно.

Можно создавать неизменяемые объекты через статическую фабрику(Item) и кешировать часто запрашиваемые объекты.

Можно совместно использовать не только неизменяемые объекты, но и их внутреннее представление.

Неизменяемые объекты образуют крупные строительные блоки для прочих объектов.

Неизменяемые объекты обеспечивают атомарность.

Основным недостатком неизменяемых классов является то, они требуют отдельных объектов для каждого уникального значения.
И следствие повышение производительности.

Запретить наследование, помимо final, можно сделать его конструктор закрытым или доступным на уровне пакета и добавить
статистическую фабрику([Item 1](#21-рассмотрите-применение-статических-фабричных-методов-вместо-конструкторов-item-1)).

```java
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }
}

```

Данный подход позволяет использовать несколько классов реализации, доступных в пределах пакета. За пределами пакета,
неизменяемый класс является финальным.

Если класс невозможно сделать неизменяемым, нужно максимально ограничить изменяемость и видимость.

## 4.4 Предпочитайте композицию наследованию (Item 18)

Речь идет только на наследовании от другого класса, а не реализации интерфейса.

Наследование нарушает инкапсуляцию.

- Реализация суперкласса может меняться от версии к версии, и, если это происходит,
  подкласс может перестать корректно работать, даже если его код останется нетронутым.
- В новых версиях суперкласса может появиться новый метод, который не будет учитываться в подклассах и может привести
  проблемы с безопасностью.

Композиция - вместо наследования в классе, создать в нем закрытое поле, которое будет содержать ссылку на экземпляр
существующего класса. Каждый метод экземпляра в новом классе вызывает соответсвующий метод содержащего в классе
экземпляра существующего класса, а затем возвращает полученный результат. Эта технология передачи(forwarding), а
методы - методы передачи (forwarding methods).

```java
// Wrapper class - uses composition in place of inheritance
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

// Reusable forwarding class
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;

    public ForwardingSet(Set<E> s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator<E> iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection<?> c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection<? extends E> c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection<?> c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection<?> c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public <T> T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}

```

У данного подхода мало недостатков, один из них SELF problem, остальные менее существенные.

Пользоваться наследованием можно, если между классом и суперклассом есть реальная связь типа и подтипа. Но даже в этом
случае применение наследование может сделать программу ненадежной, особенно если подкласс и суперкласс принадлежат к
разным пакетам, а сам суперкласс не был изначально предназначен для расширения.

## 4.5 Проектируйте и документируйте наследование, либо запрещайте его (Item 19)

Класс должен документировать, какие из методов он использует сам(self-use), которые могут быть переопределены. Для
каждого открытого или защищенного метода документация должна указывать, какие методы, которые могут быть переопределены,
он вызывает, в какой последовательности, а также каким образом результаты их вызова влияют на дальнейшую работу.

Для создания более эффективных подклассов, класс может предоставлять точки входа при внутренней обработке в виде разумно
выбранных защищенных методов.

Единственный способ протестировать класс, предназначенный для наследования - написать подклассы.
Необходимо протестировать класс путем написания подклассов до того, как он буде выпущен.

Конструкторы класса не должны вызывать методы, которые могут быть переопределены, не напрямую и не косвенно.

Если родительский класс реализовывает интерфейс Cloneable или Serializable, то ни методу clone, ни методы readObject не
разрешается вызывать методы, которые могут быть перекрыты, ни непосредственно, ни косвенно. Также эти методы должны
иметь модификатор доступа protected.

Если класс не предполагается для наследования, то лучше запретить наследование данного класса:

- Объявить как final
- Сделать все конструкторы закрытыми или доступные в пределах пакета, а вместо них использовать статистические фабрики.

## 4.6 Предпочитайте интерфейсы абстрактным классам (Item 20)

В Java разрешено только единичное наследование, это ограничение на абстрактные классы серьезно сдерживает их
использование в качестве определений типов.

Существующие классы можно легко приспособить для реализации нового интерфейса.

Интерфейсы идеально подходят для создания миксинов(класс, который может иметь дополнительное поведение).

Интерфейс позволяет создавать фреймворк неиерархического типа.

Интерфейс обеспечивают безопасное и мощное развитие функциональности с сипользованием класса-оболочки(Item)

Можно объединить преимущества интерфейсов и абстрактных классов, предоставляя абстрактный класс скелетной реализации,
сопутствующий интерфейсу.

```java
// Concrete implementation built atop skeletal implementation (Page 101)
public class IntArrays {
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);

        // The diamond operator is only legal here in Java 9 and later
        // If you're using an earlier release, specify <Integer>
        return new AbstractList<>() {
            @Override
            public Integer get(int i) {
                return a[i]; // Autoboxing (Item 6)
            }

            @Override
            public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val; // Auto-unboxing
                return oldVal; // Autoboxing
            }

            @Override
            public int size() {
                return a.length;
            }
        };
    }
}

```

Необходима документация скелетной реализации.

## 4.7 Проектируйте интерфейсы для потомков (Item 21)

В Java 8 у интерфейсов появились дефолтные методы, но добавление новых методов к существующим интерфейсам сопряжено с
риском. Которые имеют дефолтные реализации, при не во всех реализациях интерфейса может корректно работать метод.

Не всегда возможно написать дефолтный метод, который поддерживает все инварианты всех мыслимых реализаций.

В присутствии дефолтных методов существующие реализации интерфейсов могут компилироваться без ошибок или предупреждений,
но сбоить во время выполнения.

## 4.8 Используйте интерфейсы только для определения типов (Item 22)

Интерфейс следует использовать в качестве определения типа, который может быть использован для ссылки на экземпляры
класса.

Не следует использовать интерфейс констант:

```java
// Constant interface antipattern. Don't do it !
public interface PhysicalConstants {
    static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    static final double BOLTZMAN_CONSTANT = 1.380_648_52e-23;
}

```

Лучше использовать утильный класс констант:

```java
public class PhysicalConstants {
    private PhysicalConstants() {
    } // Prevents instantiation

    public static final double AVOGRADOS_NUMBER = 6.02214199e23;
    public static final double BOLTZAN_CONSTANT = 1.3806503e-23;
    public static final double ELECTRON_MASS = 9.10938188e-31;
}

```

## 4.9 Предпочитайте иерархии классов дескрипторам классов (Item 23)

Поле класса _дескриптор_ - указывает разновидность класса, который может находиться в разных состояниях.

Классы с дескрипторами многословны, склонны к ошибкам и неэффективны.

Применение дескрипторов является лишь бледным подобием иерархии классов. И лучше задуматься над рефакторингом.

## 4.10 Предпочитайте вложенный статический класс вложенному внутреннему классу (Item 24)

Виды классов внутри других классов(nested class) в Java:

- Вложенный статический класс(static member class)
- Вложенный внутренний класс(nonstatic member class)
- Анонимный класс(anonymous class)
- Локальный класс(local class)

Алгоритм подбора вида класса:

* Если класс внутри другого класса должен быть виден за пределами метода или он слишком длинный, для размещения в
  границах метода, используйте вложенный класс(static или nonstatic).
    * Если каждому экземпляру вложенного необходима ссылка на включающий его экземпляр, делайте его внутренним классом(
      nonstatic member class)
    * В остальных случаях статистический(static member class)
* Если класс находится внутри метода и нужно создавать экземпляр в одном месте программы и имеется тип для этого
  класса - анонимный класс(anonymous class)
* В остальных случаях локальный(local class)

## 4.11 Ограничивайтесь одним классом верхнего уровня на исходный файл (Item 25)

Никогда не размещайте несколько классов верхнего уровня или интерфейсов в одни исходном файле. Это гарантирует, что не
будет нескольких определений одного класса во время компиляции.

# 5 Обобщенное программирование

## 5.1 Не используйте сырые типы (Item 26)

Основная терминология

| **Термин**                                | **Пример**                         | **Item** |
|-------------------------------------------|------------------------------------|----------|
| Параметризованный тип                     | `List<String>`                     | 26       |
| Актуальный параметр типа                  | `String`                           | 26       |
| Обобщенный тип                            | `List<E>`                          | 26, 29   |
| Формальный параметр типа                  | `E`                                | 26       |
| Неограниченный тип с символом подстановки | `List<?>`                          | 26       |
| Сырой тип                                 | `List`                             | 26       |
| Ограниченный параметр типа                | `<E extends Number>`               | 29       |
| Рекурсивно ограниченный тип               | `<T extends Comparable<T>>`        | 30       |
| Ограниченный тип с символом подстановки   | `List<? extends Number>`           | 31       |
| Обобщенный метод                          | `static <E> List<E> asList(E[] a)` | 30       |
| Токен типа                                | `String.class`                     | 33       |

Использование сырых типов может привести к ошибке во время компиляции, по этому не рекомендуется их использовать. Они
оставлены для обратной совместимости.

```java
    private final Collection stamps=...;

        stamps.add(new Coin(...)); //Erroneous insertion. Does not throw any error

        Stamp s=(Stamp)stamps.get(i); // Throws ClassCastException when getting the Coin
```

```java
    private final Collection<Stamp> stamps=...;

        stamps.add(new Coin()); // Compile time error. Coin can not be add to Collection<Stamp>

        Stamp s=stamps.get(i); // No need casting
```

Правила образования подтипов для обобщенных типов: `List<String>` является подтипом сырого `List`, но не является
подтипом
`List<Object>`. Теряется безопасность типов при использовании сырых типов, но не при использовании параметризованных
типов типа `List<Object>`.

Если не известный фактические параметры типов, то в качестве альтернативы для несформированного типа можно использовать
неограниченный тип с символом подстановки, например `Collection<?>`. Данный подход безопасней, поскольку в данную
коллекцию нельзя поместить любой элемент(кроме `null`), а сырой тип можно.

Исключения, когда можно использовать сырые типы:

1. Необходимо использовать несформированные типы в литералах классов: `List.class`, `String[].class` и `int.class`
   разрешены, а `List<String>.class` и `List<?>.class` - нет.
2. Использование оператора `instanceof` с обобщенными типами

```java
   if(o instanceof Set){
        Set<?> =(Set<?>)o;
        }
```

## 5.2 Устраняйте предупреждение о непроверяемом коде (Item 27)

При использовании обобщенных элементов, можно столкнуться с предупреждение компилятора:

- о непроверяемом приведении
- о непроверяемом вызове метода
- о непроверяемом параметризованном типе с переменным количеством аргументов
- о непроверяемом преобразовании

Следует устранять все предупреждения о непроверяемом коде, какие можно устранить!

Если нельзя устранить предупреждения, но есть уверенность, что код, о котором предупреждает компилятор, безопасен, то
тогда(и только тогда!) можно скрыть предупреждения с помощью аннотации `@SupressWarnings("unchecked")`.

Всегда используйте аннотацию `@SupressWarnings` в наименьшей возможной области видимости.

Каждый раз при использовании `@SupressWarnings("unchecked")` нужно добавлять комментарий с пояснением, почему в данном
случае этот код безопасен.

## 5.3 Предпочитайте списки массивам (Item 28)

Отличия массивов от списков:

1. Массивы **ковариантны** - если `Sub` является подтипом `Super`, то `Sub[]` является подтипом `Super[]`. Обобщенные
   типы **инвариантны** - для двух различных типов `Type1` и `Type2` тип `List<Type1>` не является ни подтипом,
   ни супертипом `List<Type2>`.

2. Массивы являются типами, доступными во время выполнения программы. Обобщенные типы, реализуются с использованием
   затирания, то есть тип доступен во время компиляции, но во время исполнения неизвестен.

С учетом данных отличий, массивы обеспечивают безопасность времени выполнения с точки зрения типов, но не безопасность
типов при компиляции, и наоборот.

```java
class Item27 {
    void method27() {
        // Fails at runtime
        Object[] objectArray = new Long[1];
        objectArray[0] = "I don't fit in"; // Throws ArrayStoreException

        // Won't compile
        List<Object> ol = new ArrayList<Long>(); // Incompatible types
        ol.add("I don't fit in");
    }
}

```

Из-за этих отличий нельзя перемешивать листы и массивы. Нельзя создавать подобные
элементы: `List<E>[]`, `new List<String>[]`, `new E[]`.

## 5.4 Предпочитайте обобщенные типы (Item 29)

Обобщенные типы безопаснее и проще в использовании, чем типы, которые требует приведений в клиентском коде. При
разработке новых типов убедитесь, что они могут быть использованы без таких приведений.

## 5.5 Предпочитайте обобщенные методы (Item 30)

Обобщенные методы, подобно обобщенным типам, безопаснее и проще в использовании, чем методы требующие от своих клиентов
использовать явные приведения входных параметров и возвращаемых значений.

Для метода сравнения объектов в коллекции, каждый объект должен быть сопоставим с любым другим её элементом. Этом можно
сделать с помощью рекурсивного ограничения `<E extends Comparable<E>>`.

## 5.6 Используйте ограниченные символы подстановки для повышения гибкости API (Item 31)

Поскольку параметризованные типы являются инвариантными, то невозможно в коллекцию `List<Nubmer>` вставить
объект `Integer` используя только формальный параметр типа `E`.

```java
class Item31 {
    public void pushAll(Iterable<E> src) {
        for (E e : src)
            puhs(e);
    }

    public static void main(String[] args) {
        // Integer is a subtype of Number
        Stack<Number> numberStack = new Stack<Number>();
        Iterable<Integer> integers =...;
        numberStack.pushAll(integers); //Error message here: List<Integer> is not a subtype of List<Number>
    }
}
```

Что бы это было возможно, можно использовать ограниченный символ подстановки

Producer:

```java
class Item31 {
    // We want to push in everything that is E or inherits E
    public void pushAll(Iterable<? extends E> src) {
        for (E e : src) {
            push(e);
        }
    }
}

```

В данном случае параметризованный тип является производителем(producer). Также параметризованный тип может быть
потребителем(consumer), например получить объекты.

Consumer:

```java
class Item31 {
    public void popAll(Collection<? super E> dst) {
        while (!isEmpty()) dst.add(pop());
    }
}

```

Правило **PECS** - producer-extends, consumer-super

Не используйте ограниченные типы с символами подстановки в качестве возвращаемых типов. Пользователь данного элемента не
должен думать о типах символов подстановки.

`Comparable` и `Comparators` всегда потребители. Используйте `Comparable<? super T>` и `Comparator<? super T>`.

Если параметр типа появляется в объявлении метода только один раз, его следует заменить символом подстановки:

```java
public static<E> void swap(List<E> list,int i,int j)
public static void swap(List<?> list,int i,int j) //Более предпочтительный способ
```

## 5.7 Аккуратно сочетайте обобщенные типы и переменное количество аргументов (Item 32)

Следует помнить, что методы с переменным количеством аргументов и обобщенные типы взаимодействуют не очень хорошо,
потому что параметр переменной длины представляет собой утечку абстракции, построенную поверх массива, а правила типов
для массивов отличаются от правил для обобщенных типов.

Если метод вызывается с переменным числом параметров, выведение типов которых недоступен во время выполнения, компилятор
выдает предупреждение для такого вызова.

Опасно хранить значение в обобщенном массиве-параметре переменной длины.

```java
public class Dangerous {
    // Mixing generics and varargs can violate type safety!
    static void dangerous(List<String>... stringLists) {
        List<Integer> intList = List.of(42);
        Object[] objects = stringLists;
        objects[0] = intList; // Heap pollution
        String s = stringLists[0].get(0); // ClassCastException
    }
}

```

Но методы с переменным количеством параметров обобщенных или параметризованных типов могут быть весьма полезны на
практике, поэтому разработчики языка решили оставить эту несогласованность `Arrays.asList(T... a)`, `Collections.addAll(
Collection<? super T c, T... elements>)` и `EnumSet.of(E first, E... rest)`.

Обобщенный метод с переменным количеством аргументов безопасен, если:

1. он ничего не сохраняет в массиве параметра переменной длины;
2. он не делает массив (или его клон) видимым ненадежному коду.

Аннотация SafeVarargs представляет собой обещание безопасности с точки зрения типов от автора метода. Используйте
SafeVarargs с каждым методом с параметром переменной длины обобщенного или параметризованного типа, если гарантируете
безопасность.

## 5.8 Применяйте безопасные с точки зрения типов гетерогенные контейнеры (Item 33)

Использование обобщенных типов ограничивает фиксированным количествам параметров типа в контейнере, например
коллекции `Set<E>`. Нельзя сделать произвольное количество параметров типа `Set<E...>`.

Можно это обойти, помещая параметр типа в ключ, а не в контейнер.

```java

public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();

    public <T> void putFavorites(Class<T> type, T instance) {
        if (type == null)
            throw new NullPointerException("Type is null");
        favorites.put(type, type.cast(instance));//runtime safety with a dynamic cast
    }

    public <T> getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}

```

# 6 Перечисления и аннотации

## 6.1 Используйте перечисление вместо констант int (Item 34)

Тип перечисления(enum) - это классы, которые экспортируют по одному экземпляру для каждой константы перечисления,
используя открытое статическое финальное поле.

До того как типы перечисление появились в языке Java, был распространен шаблон перечисления int(int enum pattern).
Данный способ не обеспечивает ни безопасности с точки зрения типов, ни выразительности. Данный шаблон больше не
рекомендуется. Так же как и шаблон перечисления String(String pattern enum), который к тому же не производительный.

Чтобы связать данные с константами причисления, следует объявить поля экземпляров и написать конструктор, который
получает данные и сохраняет их в поле. Перечисления неизменяемые, все поля должны быть `final`(Item). Также желательно
их сделать `private`.

```java
public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS(4.869e+24, 6.052e6);
    // ...

    private final double mass; // In kilograms
    private final double radius; // In meters
    private final double surfaceGravity; // In m / s^2

    // Universal gravitational constant in m^3 / kg s^2
    private static final double G = 6.67300E-11;

    // Constructor
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass() {
        return mass;
    }

    public double radius() {
        return radius;
    }

    public double surfaceGravity() {
        return surfaceGravity;
    }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}

```

Если применение enum связано с определенным классом верхнего уроня, оно должно быть классом-членом класса верхнего
уровня(Item).

Можно связать поведение с константами. Для этого нужно объявить абстрактный метод в типе перечисления и перекрыть его
конкретным методом для каждой константы в теле класса, зависимого от константы(constant-specific class body). Такие
методы известны как реализации методов, зависимых от констант(constant-specific method implementations).

```java
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES("*") {
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            return x / y;
        }
    };

    private final String symbol;

    Operation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }

    public abstract double apply(double x, double y);

    // Implementing a fromString method on an enum type (Page 164)
    private static final Map<String, Operation> stringToEnum =
            Stream.of(values()).collect(
                    toMap(Object::toString, e -> e));

    // Returns Operation for string, if any
    public static Optional<Operation> fromString(String symbol) {
        return Optional.ofNullable(stringToEnum.get(symbol));
    }

    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        for (Operation op : Operation.values())
            System.out.printf("%f %s %f = %f%n",
                    x, op, y, op.apply(x, y));
    }
}
```

Применения `switch` к enum опасно с точки зрения поддержки и менее гибко. Альтернатива - использования
перечисления-стратегии.

```java
enum PayrollDay {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY(WEEKEND),
    SUNDAY(WEEKEND);

    private final PayType payType;

    PayrollDay() {
        this(WEEKDAY); // default
    }

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    int pay(int minutesWorked, int payRate) {
        return payType.pay(minutesWorked, payRate);
    }

    // The strategy enum type
    enum PayType {
        WEEKDAY {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked <= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2;
            }
        },
        WEEKEND {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked * payRate / 2;
            }
        };

        abstract int overtimePay(int mins, int payRate);

        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minsWorked, int payRate) {
            int basePay = minsWorked * payRate;
            return basePay + overtimePay(minsWorked, payRate);
        }
    }

    public static void main(String[] args) {
        for (PayrollDay day : values()) System.out.printf("%-10s%d%n", day, day.pay(8 * 60, 1));
    }
}

```

Конструкция switch с перечислениями хорошо подходит для дополнения типов перечислений поведением, зависимым от констант.

```java
public class Inverse {
    public static Operation inverse(Operation op) {
        switch (op) {
            case PLUS:
                return Operation.MINUS;
            case MINUS:
                return Operation.PLUS;
            case TIMES:
                return Operation.DIVIDE;
            case DIVIDE:
                return Operation.TIMES;

            default:
                throw new AssertionError("Unknown op: " + op);
        }
    }
}

```

Используйте перечисления всегда, когда требуется набор констант, члены которых известны во время компиляции.

## 6.2 Используйте поля экземпляра вместо порядковых значений (Item 35)

Никогда не выводите значение, связанное с перечислением, из его порядкового номера; вместо этого храните его в поле
экземпляра.

Лучше так не делать:

```java
public enum Ensemble {
    SOLO,
    DUET,
    TRIO;

    public int numberOfMusicians() {
        return ordinal() + 1;
    }
}

```

Так можно:

```java
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3);

    private final int numberOfMusicians;

    Ensemble(int size) {
        this.numberOfMusicians = size;
    }

    public int numberOfMusicians() {
        return numberOfMusicians;
    }
}

```

## 6.3 Используйте EnumSet вместо битовых полей (Item 36)

До появления enum, если элементы перечисляемого типа использовались в коллекциях, то применялась схема битовых полей.

Лучшая альтернатива использовать коллекцию EnumSet, которая объединяет в себе кратность и производительность битовых
полей, со всем преимуществами enum.

## 6.4 Используйте EnumMap вместо индексирования порядковыми номерами (Item 37)

Используйте EnumMap, если требуется сгруппировать объекты по элементам перечисления.

```java
class Plant {
    Map<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle =
            Arrays.stream(garden)
                    .collect(groupingBy(p -> p.lifeCycle, () -> new EnumMap<>(LifeCycle.class), toSet()));
}

```

Если представление является многомерным, используйте `EnumMap<...,EnumMap<...>>`.

## 6.5 Имитируйте расширяемые перечисления с помощью интерфейсов (Item 38)

Классы `enum` невозможно сделать расширяемым, потому что каждый класс неявно наследуется от класса `Enum<E>`. Но можно
имитировать расширение с помощью реализации интерфейса.

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) {
            return x + y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }
}

public enum ExtendedOperation implements Operation {
    EXP("^") {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    };

    private final String symbol;

    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }
}

```

Экземпляры этих типов могут использовать везде, где могут использовать экземпляры базового типа перечисления.

## 6.6 Предпочитайте аннотации схемам именования (Item 39)

Для указания элементов, которые требуют специальной обработки исторически используется схема именования.
Например, до 4 версии `JUnit` требовалось начинать названия метода со слова `test...`.

Минусы данного подхода:

- Возможны опечатки наименования, при этом обработчик не будет жаловаться. Например, `tset`.
- Нет понятного способа определения, что схемы именования используются только в соответствующих элементах программы.
  Например, назвать класс начиная со слова `Test...`, в надежде, что методы тестов сработают, но это не так.
- Нет хорошего способа связать значения параметров с элементами программы. Например, нужно указать, чтобы тест
  обрабатывал конкретное исключение.

Использование аннотаций позволяет помечать элементы, которые требуют специальной обработки и не обладают теми же
недостатками схемы именования. Начиная с версии 4 `JUnit` используется аннотация `@Test`(аннотация-маркер) для методов
тестов.

Обязательные параметры аннотации:

Тип хранения (`@Retention(RetentionPolicy.RUNTIME)`)

| **Название** | **Описание**                                                         |
|--------------|----------------------------------------------------------------------|
| SOURCE       | Используется только при написании класса, отбрасывается компилятором |
| CLASS        | Обрабатывается во время компиляции, но игнорируется JVM              |
| RUNTIME      | Обрабатывается во время компиляции и JVM                             |

Тип возможного использования(`@Target(ElementType.METHOD)`)

| **Название**    | **Описание**            |
|-----------------|-------------------------|
| ANNOTATION_TYPE | Другая аннотация        |
| CONSTRUCTOR     | Конструктор класса      |
| FIELD           | Поле класса             |
| LOCAL_VARIABLE  | Локальная переменная    |
| METHOD          | Метод класса            |
| PACKAGE         | Описание пакета         |
| PARAMETER       | Параметр метода         |
| TYPE            | Указывается над классом |

Аннотация, использование, обработка:

```java
//Annotation with array parameter
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception>[] value();
}

    //Usage of the annotation
    @ExceptionTest({IndexOutOfBoundsException.class, NullPointerException.class})
    public void myMethod() {
    }

//By reflexion you can use the annotation this way
m.isAnnotationPresent(ExceptionTest.class);
//Or get the values this way :
        Class<?extends Exception>[]excTypes=m.getAnnotation(ExceptionTest.class).value();

```

Плюсы аннотации:

- При неправильном именовании, может не пройти компилятор (`@Retention(RetentionPolicy.RUNTIME)`)
- Можно ограничить использование элемента (`@Target(ElementType.METHOD)`)
- Можно указать параметр аннотации в качестве примитивного типа, объекта или
  массива (`@ExceptionTest({IndexOutOfBoundsException.class, NullPointerException.class}`)
- Можно использовать повторяемый тип аннотации:

```java
@ExceptionTest(IndexOutOfBoundsException.class)
@ExceptionTest(NullPointerException.class)
public static void doublyBad(){}
```

## 6.7 Последовательно используйте аннотацию Override (Item 40)

Следует использовать аннотацию Override для каждого объявления метода, которое, как вы полагаете, перекрывает объявление
суперкласса.

Если объявить её у метода, который неправильно переопределяет метод суперкласса, то компилятор вызовет ошибку.

```java
@Override //Compilation error
public boolean equals(Bigram b){
        return b.first==first&&b.second==second;
        }

@Override //  The correct sign to override the super method
public boolean equals(Object b){}

```

## 6.8 Используйте интерфейсы-маркеры для определения типов (Item 41)

Интерфейс-маркер представляет собой интерфейс, не содержащий методов для реализации, а лишь маркирует класс, реализующий
интерфейс, как имеющий определенные свойства. Например, `Serializable`.

Преимущества интерфейс-маркеров над аннотациями-маркерами(Item):

- Интерфейсы-маркеры определяют тип, который реализуется экземплярами маркированного класса; аннотации-маркеры этим
  свойством не обладают(Отловить ошибки во время компиляции);
- Интерфейсы-маркеры могут быть более точно нацелены;

Преимущество аннотации-маркерами перед интерфейсами-маркерами: они являются частью более мощной системы аннотации.

Необходимо использовать аннотации, если маркер применяется к любому элементу программы, кроме класса или интерфейса.
Если маркер применяется только к классам или интерфейсам, то нужно задать себе вопрос: "Может ограничиться одним или
несколькими методами, которые принимают только объекты маркеры?". Если это так, то предпочесть интерфейс-маркер.

Если вы пишете тип аннотации-маркера, целью которого является ElementType.TYPE, то потратьте время на выяснение,
действительно ли это должен быть тип аннотации или же более целесообразным будет применение интерфейса-маркера.

# 7 Лямбда-выражения и Stream API

## 7.1 Предпочитайте лямбда-выражения анонимным классам (Item 42)

Функциональный интерфейс(до Java 8 "функциональный тип") - это интерфейс, который имеет один метод для реализации. При
этом нет ограничения на другие методы.
Функциональный объект - это экземпляр класса, реализующий функциональный интерфейс.

До Java 8, основным способом создания функционального объекта был анонимный класс(Item). В Java 8 язык формализовал
концепцию интерфейсов с единственным абстрактным методом как отдельную, заслуживающую особой обработки. И язык позволяет
создавать их экземпляры с помощью лямбда-выражений. Лямбда-выражения функционально равны анонимным классам.

```java
public class SortFourWays {
    public static void main(String[] args) {

        // Anonymous class instance as a function object - obsolete!
        Collections.sort(
                words,
                new Comparator<>() {
                    @Override
                    public int compare(String s1, String s2) {
                        return Integer.compare(s1.length(), s2.length());
                    }
                });

        // Lambda expression as function object (replaces anonymous class)
        Collections.sort(
                words,
                Comparator < String > comparator = (s1, s2) -> Integer.compare(s1.length(), s2.length()));
    }
}

```

Типы для лямбда-выражения самого объекта и его параметров можно не записывать, компилятор определяет типы из контекста.
Опустите типы всех параметров лямбда-выражения, если только они не делают вашу программу яснее.

Реализацию компаратора можно и упростить, использовав метод постоения компаратора + ссылку на метод(
Item): `Collections.sort(words, comparingInt(String::length)))`.

Добавление лямбда-выражения в язык делает практичным использование функциональных объектов.

В примере из Item поведение связанное с константами, можно реализовать с помощью лямбда-выражения, использовав
стандартный функциональный интерфейс `DoubleBinaryOperator`(Item) и реализовать метод `apply`, который делегирует вызов
метода функционального объекта `applyAsDouble`:

```java
public enum Operation {
    PLUS("+", (x, y) -> x + y),
    MINUS("-", (x, y) -> x - y),
    TIMES("*", (x, y) -> x * y),
    DIVIDE("/", (x, y) -> x / y);

    private final String symbol;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    @Override
    public String toString() {
        return symbol;
    }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }

    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        for (Operation op : Operation.values())
            System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
    }
}

```

Если вычисление не требует оставлять пояснений в виде комментариев или превышает несколько строк, не используйте для
него лямбда-выражение.

Для лямбда-выражения идеально одна строка кода, а три это разумный максимум. Если лямбда-выражения длинное или сложное
для чтения, либо упростите его, либо сделайте рефакторинг и замените его.

Что можно сделать с анонимными классами, и нельзя - с лямбда-выражениями.

- Если нужно создать экземпляр абстрактного класса, то это можно сделать с помощью анонимного класса, но не
  лямбда-выражения.
- Анонимные классы можно использовать для создания экземпляров интерфейсов с несколькими абстрактными методами.
- Лямбда-выражения не может получить ссылку на себя. В лямбда-выражение ключевое слово `this` ссылается на объект в
  котором содержится лямбда выражение. В анонимном классе ключевое слово `this` ссылается на экземпляр анонимного
  класса.

Лямбда-выражения, как и экземпляр анонимного класса нельзя надежно сериализовать и десериализовать. Нужно редко (если
вообще придется это делать) сериализовать лямбда-выражение.

## 7.2 Предпочитайте ссылки на методы лямбда-выражениям (Item 43)

Помимо лямбда-выражения, есть более краткий способ создать функциональный интерфейс - ссылки на метод. Если у метода, на
который необходимо указать ссылку, параметры совпадают с параметрами лямбда-выражения, то можно использовать специальную
запись в виде ссылки на метод:

```java
public class Freq {
    public static void main(String[] args) {

        // Lambda
        frequencyTable.merge(s, 1, (count, incr) -> count + incr);

        // Lambda with Integer static method
        frequencyTable.merge(s, 1, (count, incr) -> Integer.sum(count, incr));

        // Method reference
        frequencyTable.merge(s, 1, Integer::sum);
    }
}

```

Чаще ссылка на метод имеет более краткую запись, чем лямбда-выражения. Но если это не так, то лучше использовать
лямбда-выражения:

`service.execute(GoshThisClassNameIsHumongous::action);`

`service.execute(() -> action());`

Типы ссылок на методы

| **Тип ссылки**      | **Пример**               | **Эквивалетное лямбда-выражение**                         |
|---------------------|--------------------------|-----------------------------------------------------------|
| Статическая         | `Integer::parseInt`      | `str -> Integer.parseInt(str)`                            |
| Ограниченная        | `Instant.now()::isAfter` | `Instant then = Instant.now();`<br/>` t->then.isAfter(t)` |
| Неограниченная      | `String::toLowerCase`    | `str -> str.toLowerCase()`                                |
| Конструктор класса  | `TreeMap<K,V>::new`      | `() -> new TreeMap<K,V>`                                  |
| Конструктор массива | `int[]::new`             | `len -> new int[len]   `                                  |

## 7.3 Предпочитайте использовать стандартные функциональные интерфейсы (Item 44)

С появлением лямбда-выражения, значительно изменились лучше практики написания API. Например, паттерн **Шаблонный метод
**, в котором подкласс переопределяет примитивный метод для специализации поведения суперкласса, становиться менее
привлекательным. Современная альтернатива - представить статическую фабрику или конструктор, который принимает
функциональный объект, с помощью чего будет достигнуть тот же результат.

Поскольку необходимость создания функционального объекта возрастает. Выбор правильного типа функционального параметра
требует внимания.

Пакет `java.util.function` предоставляет вам большую коллекцию стандартных функциональных интерфейсов. Если один из
стандартных функциональных интерфейсов выполняет нужную вам работу, в общем случае следует использовать именно его, а не
специализированный функциональный интерфейс.

Основные функциональные интерфейсы:

| **Интерфейс**       | **Сигнатура функции** | **Пример**            |
|---------------------|-----------------------|-----------------------|
| `UnaryOperator<T>`  | `T apply(T t)`        | `String::toLowerCase` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | `BigInteger::add`     |
| `Predicate<T>`      | `boolean test(T t)`   | `Collection::isEmpty` |
| `Function<T,R>`     | `R apply(T t)`        | `Arrays::asList`      |
| `Supplier<T>`       | `T get()`             | `Instant::now`        |
| `Consumer<T>`       | `void accept(T t)`    | `System.out::println` |

Если необходимо написать собственный функциональный интерфейс, то к разработке необходимо отнестись с осторожностью (
Item). Всегда аннотируйте ваши функциональные интерфейсы с помощью аннотации `@FunctionalInterface`.

Не делайте перезагрузку метода(Item), которые принимают разные функциональные интерфейсы в одно и той же позиции
аргумента, если это может привести к возможной неоднозначности в команде клиента. Например, в `ExecutorService` метод
submit может принимать `Callable<T>` или `Runnable`.

## 7.4 Разумно используйте Stream API (Item 45)

Stream API - это инструмент, который позволяет работать со структурами данных в стиле функциональных языков
программирования.

Stream API имеет два вида методов:

1. Конвейерные — возвращают другой stream, то есть работают как builder,
2. Терминальные — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.

Stream API вычисляются отложено: вычисления не начинаются до тех пор, пока не будет вызвана завершающая операция, и
никогда не вычисляются элементы данных, которые не нужны для выполнения заверщающей опкерции.

Stream API может выполнять операции как последовательно, так и паралельно, для этого нужно вызвать метод `parallel` для
любого потока в конвейере, но это уместным бывает редко.

Злоупотребелние Stream API затрудняет чтение и поддержку кода.

Без Stream API:

```java
// Prints all large anagram groups in a dictionary iteratively
public class IterativeAnagrams {
    public static void main(String[] args) throws IOException {
        File dictionary = new File(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();
                groups.computeIfAbsent(alphabetize(word),
                        (unused) -> new TreeSet<>()).add(word);
            }
        }

        for (Set<String> group : groups.values())
            if (group.size() >= minGroupSize)
                System.out.println(group.size() + ": " + group);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}

```

Злоупотребление Stream API:

```java
// Overuse of streams - don't do this!
public class StreamAnagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                            groupingBy(word -> word.chars().sorted()
                                    .collect(StringBuilder::new,
                                            (sb, c) -> sb.append((char) c),
                                            StringBuilder::append).toString()))
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .map(group -> group.size() + ": " + group)
                    .forEach(System.out::println);
        }
    }
}
```

Корректное применение Stream API:

```java
// Tasteful use of streams enhances clarity and conciseness
public class HybridAnagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> alphabetize(word)))
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .forEach(g -> System.out.println(g.size() + ": " + g));
        }
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

В отсутствии явного указания типов тщательное именование параметров лямбда-выражения имеет важное значение для
удобочитаемости конвейеров потоков. В примере `HybridAnagrams` параметр `g`, должен назваться `group`, но
тогда получилось длинная строка.

Применение вспомогательных методов для удобочитаемости в конвейерах потоков даже более важно, чем в итеративном коде. В
примере `HybridAnagrams` используется метод `alphabetize`.

Воздерживайтесь от использования потоков для обработки значений типа char:

`"Hello world!".chars().forEach(System.out::print); -> 721011081081113211911111410810033`

`"Hello world!".chars().forEach(x -> System.out.print((char) x)); -> Hello world!`

Выполняйте рефакторинг существующего кода для использования потоков и используйте их в новом коде только там, где это
имеет смысла.

Конвейерные методы используют в основном в качестве параметра функциональные объекты. Есть вещи, которые можно сделать
с помощью блоков кода с `for`, но не получиться сделать из функциональных объектов в Stream API:

- Из блока кода можно прочесть или изменить любую локальную переменную в области видимости; из лямбда-выражения можно
  прочесть только финальные или фактически финальные переменные, и нельзя изменять никакие локальные переменные.
- В блоке кода можно выполнить оператор `return` для выхода из охватывающего метода, прервать или продолжить выполнение
  охватывающего цикла с помощью оператора `break` и `continuе`, или сгенерировать любое проверяемое исключение, которое
  этот метод объявил как могущее быть сгенерированным; из лямбда-выражения нельзя сделать ни одно из перечисленных
  действий.

Но что можно сделать с помощью Stream API:

- Единообразное преобразование последовательностей элементов.
- Фильтрование последовательностей элементов.
- Объединение последовательностей элементов с помощью единственной операции(например, сложение, конкатенация или
  вычисление минимума).
- Накопление последовательности элементов в коллекции, возможно, с группировкой по некоторым общим атрибутам.
- Поиск в последовательности элементов некоторого элемента, удовлетворяющего некоторым критериям поиска.

В Stream API сложно сделать одновременное обращение к элементам на разных этапах конвейера. Одним из способов обхода
этого является отображение каждого значения на объект пары, содержащий исходное и новое значения, но это решение не
является удовлетворительным, в особенности если такие объекты пар требуются для нескольких этапов конвейера. Такой код
беспорядочный и многословный. Когда это приемлемо, когда нужен доступ к значению на более ранней стадии вычислений,
лучше инвертировать использованное отображение.

```java
    static Stream<BigInteger> primes(){
        return Stream.iterate(TWO,BigInteger::nextProbablePrime);
        }
```

Есть много задач, для которых не очевидно, что следует использовать: Stream API или итерации. Все сводится к личным
предпочтениям и среде разработки.

Пример:

```java
public class Card {
    // Iterative Cartesian product computation
    private static List<Card> newDeckIterative() {
        List<Card> result = new ArrayList<>();
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values()) result.add(new Card(suit, rank));
        return result;
    }

    // Stream-based Cartesian product computation
    private static List<Card> newDeckStream() {
        return Stream.of(Suit.values())
                .flatMap(suit -> Stream.of(Rank.values()).map(rank -> new Card(suit, rank)))
                .collect(toList());
    }
}

```

## 7.5 Предпочитайте в потоках функции без побочных эффектов (Item 46)

Stream API это не просто инструмент для работы со структурами данных, это целая парадигма основанная функциональном
программировании. Поэтому, чтобы получить выразительность, скорость и возможность параллельных вычислений, при работе с
потоками, нужно принять саму парадигму.

Важная часть парадигмы Stream API это приближение результата вычислений к чистой функции. Чистая функция - это функция,
результат которой зависит только от входных данных, и при этом никак не зависит от какого-либо изменяемого состояния,
так и не обновляет никакое состояние. Для этого нужно добиться, что бы функциональные объекты потоковых операций, были
без побочных эффектов. А не маскировать интервальный код, под потоковое вычисление.

*Входные данные не должные зависеть от изменяемого состояния указывает* - из лямбда-выражения можно прочесть только
финальные или фактически финальные переменные, и нельзя изменять никакие локальные переменные(Item).

Операция `forEach` должна использоваться только для того, чтобы вывести результат потоковых вычислений, но не для
выполнения вычислений.

```java
public class Freq {
    public static void main(String[] args) {

        // Uses the streams API but not the paradigm--Don't do this!
        Map<String, Long> freq = new HashMap<>();
        try (Stream<String> words = new Scanner(file).tokens()) {
            words.forEach(
                    word -> {
                        freq.merge(word.toLowerCase(), 1L, Long::sum);
                    });
        }

        // Proper use of streams to initialize a frequency table
        Map<String, Long> freq;
        try (Stream<String> words = new Scanner(file).tokens()) {
            freq = words.collect(groupingBy(String::toLowerCase, counting()));
        }
    }
}

```

Для того чтобы правильно использовать потоки, нужно лучше изучить `Collectors`. Наиболее
важные: `toList`, `toSet`, `toMap`, `groupingBy` и `joing`.

## 7.6 Предпочитайте коллекции потокам в качестве возвращаемых типов (Item 47)

При написании метода, который возвращает последовательность элементов, клиенту может потребовать вернуть их как
коллекцию или вернуть их как поток.

`Сollection` или подходящий подтип в общем случае является наилучшим типом возвращаемого значения для открытого метода,
возвращающего последовательность. Поскольку `Collection` подтип `Iterable` и обеспечивает итеративный доступ, а также
имеет метод `stream` и обеспечивает также же потоковый доступ.

Если невозможно вернуть коллекцию, то нужно вернуть `Stream` или `Iterable`, в зависимости от задачи. `Stream` не
расширяет `Iterable`, поэтому отсутствует итеративный доступ. Но можно написать свои адаптеры `Stream` - `Interable`:

```java
public class Adapters {
    // Adapter from  Stream<E> to Iterable<E>
    public static <E> Iterable<E> iterableOf(Stream<E> stream) {
        return stream::iterator;
    }

    // Adapter from Iterable<E> to Stream<E>
    public static <E> Stream<E> streamOf(Iterable<E> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }
}

```

## 7.7 Будьте внимательны при многопоточном использовании Stream API (Item 48)

Написание многопоточных программ на языке Java становиться все проще, но написание правильных и быстрых многопоточных
программ остается таким же сложным, как и ранее.

Что сделать конвейерные операции в Stream API многопоточными, нужно вызвать метод `parallel()`.

Многопоточные конвейерные операции вряд ли увеличат производительность, если источник получен от `Stream.iterate` или
используется промежуточная операция `limit`.

Не делайте многопоточные Stream API без надлежавшего разбора его работы.

Выигрыш в производительности от применения параллелизма оказывается наибольшим в случае обработки
экземпляров `ArraysList`, `HashMap`, `HashSet` и `ConcurrentHashMap`; массивами; диапазонами `int` и `long`. Основные
факторы:

- Эти структуры могут точно и дешево быть разделены на поддиапазоны любых желаемых размеров, что позволяет легко
  разделить работу при многопоточности
- Они обеспечивают очень хорошую локальность ссылок при последовательной обработке: ссылки последовательных элементов
  хранятся в памяти рядом одна с другой.

Если значительное количество работы выполняется в завершающей операции, то мультипольный конвейер будет иметь
ограниченную эффективность. С точки зрения многопоточности, лучшие завершающие операции это
приведения: `reduce`, `min`, `count`, `sum`. А операции, выполняемые `collect`, плохие кандидаты для многопоточности
из-за накладные расходов объединения коллекции.

Многопоточность Stream API может привести не только к низкой производительности, включая ошибки живучести, но и к
неверным результатам и непредсказуемому поведению(ошибкам безопасности).

При соответствующих обстоятельствах можно достичь ускорения, почти линейно зависящего от количества ядер процессора,
просто добавив вызов `parallel` в конвейер потока.

# 8 Методы

## 8.1 Проверяйте корректность параметров (Item 49)

При написании метода или конструктора, нужно продумать какие ограничения имеются для его параметров. Необходимо отразить
эти ограничения в документации, а также реализовать в начале работы метода явную проверку их выполнения. А отказ от
этого может привести к нарушению принципа атомарности сбоев.

В документации, исключения которые могут быть сгенерированы при неправильном параметре помечаются
дескриптором `@throws`(Item). Основные используемы для этого
исключения: `IllegalArgumentException`, `IndexOutOfBoundsException` и `NullPointerException`(Item).

Метод `Objects.requireNonNull`, гибкий и удобный, так что больше нет никакой причины для проверки значения `null`
вручную.

Для методов с модификатором доступа `private`, можно использовать проверку параметров с помощью `assert`:

```java
class SortUtil {
    private static void sort(long a[], int offset, int length) {

        assert a != null;
        assert offset >= 0 && offset <= a.length;
        assert length >= 0 && length <= a.length - offset;
    }
}

```

Отличия `assert` от обычных проверок:

1. Если условия не выполнится, то генерируется исключение `AssertionError`.
2. Они не выполняют никаких действий и не имеют стоимости при их отключения с помощью флага командной строки `java -ea`.

Важно проверять правильность параметров, которые методом не используются, а откладываются для последующей обработки.

Можно не делать проверку, если она является дорогостоящей или непрактичной операцией, и при этом параметры неявно
проверяются непосредственно в процессе выполнения вычисления.

Если в ходе вычисления методом происходит неявная проверка корректности параметра, и если проверку не проходит, то
генерируется исключение, которое не соответствует исключению из документации. Здесь можно использовать идиому трансляции
исключения(Item).

## 8.2 При необходимости создавайте защитные копии (Item 50)

Нужно писать программы оборонительно - исходя из предположения, что клиенты вашего класса будут предпринимать все
возможное для того, чтобы разарушить его инварианты.

Некорректный "неизменяемый" класс:

```java
public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) throw new IllegalArgumentException(start + " after " + end);
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }
}

```

Атака - изменение внутренних данных:

```java
        Date start=new Date();
        Date end=new Date();
        Period p=new Period(start,end);
        end.setYear(78); // Modifies internals of p!

```

В частном случае `Date` является устаревшим классом и не должен испльзоваться в новом коде.

В общем случае для защиты необходиом сделать защитную копию каждого изменяемого параметра конструктора:

```java
public Period(Date start,Date end){
        this.start=new Date(start.getTime());
        this.end=new Date(end.getTime());

        if(this.start.compareTo(this.end)>0)
        throw new IllegalArgumentException(
        this.start+" after "+this.end);
        }

```

Копии делаются до проверки параметров(Item), так что проверка корректности выполняется над копией, а не над оригиналом.
Это позволяет защитить от атаки между проверкой и использованием.

Не используйте clone для создания копии параметров, тип которого позволяет ненадежным сторонам создавать подклассы.

Вторая атака - изменение внутренних данных, через методы доступа:

```java
        Date start=new Date();
        Date end=new Date();
        p=new Period(start,end);
        p.end().setYear(78);  // Modifies internals of p!

```

Для защиты, нужно возвращать копии изменяемых внутренних объектов:

```java
public Date start(){return new Date(start.getTime());}

public Date end(){return new Date(end.getTime());}

```

Лучше использовать неизменяемые объекты(Item) в качестве компонентов.

Возможно будет снижение производительности из-за создания копии. По-этому необходимо анализировать: если вы доверяете
вызываемому объекту, то можно копии не делать.

## 8.3 Тщательно проектируйте сигнатуры методов (Item 51)

Советы по проектированию API:

- Тщательно выбирайте имена методов(Item)
- Не заходите слишком далеко в погоне за удобством методов. Не создавайте их слишком много
- Избегайте длинных списков параметров. 4 параметра - это максимум. Особенно вредны длинные последовательности
  параметров одного и того же типа. Что сократить есть следующие приемы: разбить метод на подметоды; создать
  вспомогательный класс, хранящий группы параметров - обычно используют вложенный статический класс(Item); использовать
  шаблон строитель(Item).
- Предпочитайте в качестве типов параметров интерфейсы, а не классы(Item)
- Предпочитайте двухэлементные типы перечислений для
  параметров `boolean`: `public enum TemperatureScale {CELSIUS, FARENHEIT}`

## 8.4 Перезагружайте методы разумно (Item 52)

Выбор среди перегруженных методов является статическим, в то время как выбор переопределенного метода - динамический.

```java
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "Set";
    }

    public static String classify(List<?> lst) {
        return "List";
    }

    public static String classify(Collection<?> c) {
        return "Unknown Collection";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(), new ArrayList<BigInteger>(), new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(
                    classify(c)); // -> Unknown Collection /n Unknown Collection /n Unknown Collection
    }
}

```

В данном случае выбрался наиболее общий тип коллекции, который указан в цикле.

Выбор того, какая из перезагрузок будет вызвана, выполняется во время компиляции.

При преопределении метода, во время выполнения программы выбирается наиболее конкретный метод:

```java
    class Wine {
    String name() {
        return "wine";
    }
}

class SparklingWine extends Wine {
    @Override
    String name() {
        return "sparkling wine";
    }
}

class Champagne extends SparklingWine {
    @Override
    String name() {
        return "champagne";
    }
}

public class Overriding {
    public static void main(String[] args) {
        Wine[] wines = {
                new Wine(), new SparklingWine(), new Champagne()
        };
        for (Wine wine : wines)
            System.out.println(wine.name()); // prints: wine, sparkling wine, and champagne
    }
}    
```

Что бы в классе CollectionClassifier тип распознавался во время выполнения. Нужно использовать один метод и
оператор `instanceof`:

```java
public class FixedCollectionClassifier {
    public static String classify(Collection<?> c) {
        return c instanceof Set ? "Set" : c instanceof List ? "List" : "Unknown Collection";
    }
}

```

Безопасная и консервативная стратегия состоит в том, чтобы никогда не экспортировать две перегрузки с одинаковым числом
параметров. При переменном количестве аргументов - не перезагружать вовсе.

Можно всегда дать методам разные имена вместо того, чтобы их перезагружать.

Если перезагруженные методы имеют одинаковое количество параметров, но имеют "совершенно иные" типы, например `int`
и `Collection` - такое допускается.

Не перегружайте методы, принимающие различные функциональные интерфейсы с одной и той же позиции аргумента.

При эволюции классов бывает необходимость нарушить рекомендации выше. Например, в Java 5
метод `String::contentEquals(StringBuffer)` переопределяется с типом параметра `CharSequence`, который является общим
для
других `String`-классов. Что бы для клиента разница в использовании не была замена, необходимо сохранить поведение и у
старого метода вызывать новый понижением типа:

```java

public boolean contentEquals(StringBuffer sb){
        return contentEquals((CharSequence)sb);
        }

```

## 8.5 Используйте методы с переменным количеством аргументов с осторожностью (Item 53)

Методы с переменным количеством аргументов, также называется методы с переменной арности, принимают нуль или более
аргументов:

```java
public class Varargs {
    // The WRONG way to use varargs to pass one or more arguments!
    static int min(int... args) {
        if (args.length == 0) throw new IllegalArgumentException("Too few arguments");
        int min = args[0];
        for (int i = 1; i < args.length; i++) if (args[i] < min) min = args[i];
        return min;
    }
}

```

Если будет вызов без аргументов, то ошибка будет во время компиляции, а не выполнения и необходимо делать доп. проверку.

Альтернатива этому - создать метод с двумя параметрами:

```java
public class Varargs {
    static int min(int firstArg, int... remainingArgs) {
        int min = firstArg;
        for (int arg : remainingArgs) if (arg < min) min = arg;
        return min;
    }
}

```

Использование параметров переменной длины могут влиять на производительность. По-этому можно определить с каким
наиболее количеством параметров вызывается метод и сделать несколько перезагрузок метода с количеством аргументов от
нуля - до популярного значения. Например, как это реализовано в `List.of()`.

## 8.6 Возвращайте пустые массивы и коллекции, а не null (Item 54)

Если метод, возвращающий коллекцию, может вернуть `null` это требует от клиента добавления проверки на `null`.

Аргументы против "`null` позволяет избежать расходов на размещение в памяти пустого контейнера":

- На этом уровне нет смысле беспокоится о производительности
- Можно возвращать пустой контейнер без выделения памяти. Например, `Collections.emptyList`

## 8.7 Возвращайте Optional с осторожностью (Item 55)

Если метод не сможет вернуть значение, есть следующие подходы для реализации данной ситуации:

- Вернуть `null`
- Сгенерировать исключение
- С Java 8 вернуть `Optional<T>`

Объекты `Optional` по духу аналогичны проверяемым исключениям(Item) - заставляют клиента признать, что возвращаемого
значения может и не быть, и требует дополнительного стереотипного кода клиента. Необрабатываемые исключения и `null`
позволяют игнорировать этот случай, что чревато плохими последствиями.

Никогда не возвращайте значение `null` из метода, возвращающего `Optional`: тем самым теряется сам смысл его
использования.

Типы контейнеров, включая коллекции, `Map`, `Stream`, массивы и `Optional`.

Следует объявлять метод как возвращающий `Optional<T>` если он не в состоянии возвратить результат, а клиенты должны
выполнить специальную обработку, когда результат не возвращается. Но возврат `Optional` может влиять на
производительность.

Никогда не следует возвращать `Optional` для упакованных примитивных типов, для этого следует
использовать: `OptionalInt`, `OptionalLong` и `OptionalDouble`.

Не следует использовать `Optional` как ключ, значение или элемент, коллекции или массива.

## 8.8 Пишите документирующие комментарии для всех открытых элементов API (Item 56)

Чтобы должным образом документировать свой API, следует предварять каждый экспортируемый класс, интерфейс, конструктор,
метод и объявление поля документирующим комментарием.

Если класс является сериализуемым, следует также документировать его сериалзиованную форму(Item).

Открытые классы не должны использовать конструкторы по-умолчанию, потому что нет никакого способа предоставить для них
документирующих комментарии.

Документирующий комментарий метода должен лаконично описывать контракт между этим методом и его клиентом:

- Контракт должен точно оговаривать, что делает данный метод, а не как он это делает
- Необходимо перечислить все предусловия и постусловия
- Обычно предусловия неявно описывается дескриптором `@throws` для непроверяемых исключений
- Предусловия могут указываться вместе с параметрами, которых они касаются, в соответствующих параметрах `@param`
- Должны быть документированы любые побочные эффекты. Побочный эффект - это наблюдаемое изменение состояние системы,
  которое является неочевидным условием для достижения постусловия.
- Каждый комментарий должен включать в себя дескрипторы: `@param`, `@return`, `@throws`.

```java
public class DocExamples<E> {

    /**
     * Returns the element at the specified position in this list.
     *
     * <p>This method is <i>not</i> guaranteed to run in constant time. In some implementations it may
     * run in time proportional to the element position.
     *
     * @param index index of element to return; must be non-negative and less than the size of this
     *     list
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException if the index is out of range ({@code index < 0 || index >=
     *     this.size()})
     */
    E get(int index) {
        return null;
    }

    // Use of @implSpec to describe self-use patterns & other visible implementation details.

    /**
     * Returns true if this collection is empty.
     *
     * @implSpec This implementation returns {@code this.size() == 0}.
     * @return true if this collection is empty
     */
    public boolean isEmpty() {
        return false;
    }

    // Use of the @literal tag to include HTML and javadoc metacharacters in javadoc comments.

    /** A geometric series converges if {@literal |r| < 1}. */
    public void fragment() {
    }

    // Controlling summary description when there is a period in the first "sentence" of doc comment.

    /** A suspect, such as Colonel Mustard or {@literal Mrs. Peacock}. */
    public enum FixedSuspect {
        MISS_SCARLETT,
        PROFESSOR_PLUM,
        MRS_PEACOCK,
        MR_GREEN,
        COLONEL_MUSTARD,
        MRS_WHITE
    }

    // Generating a javadoc index entry in Java 9 and later releases.

    /** This method complies with the {@index IEEE 754} standard. */
    public void fragment2() {
    }

    // Documenting enum constants (Page 258)

    /** An instrument section of a symphony orchestra. */
    public enum OrchestraSection {
        /** Woodwinds, such as flute, clarinet, and oboe. */
        WOODWIND,

        /** Brass instruments, such as french horn and trumpet. */
        BRASS,

        /** Percussion instruments, such as timpani and cymbals. */
        PERCUSSION,

        /** Stringed instruments, such as violin and cello. */
        STRING;
    }

    // Documenting an annotation type

    /**
     * Indicates that the annotated method is a test method that must throw the designated exception
     * to pass.
     */
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface ExceptionTest {
        /**
         * The exception that the annotated test method must throw in order to pass. (The test is
         * permitted to throw any subtype of the type described by this class object.)
         */
        Class<? extends Throwable> value();
    }
}

```

В документирующем комментарии слово `this` всегда указывает на объект, которому принадлежит вызываемый метод.

При создании класса для наследования необходимо документировать его схемы использования собственных объектов(Item), это
обычно документируется с помощью `@implSpec`.

Документирующие комментарии должны быть читаемыми как в исходном тексте, так и в сгенерированной документации.

Первым предложением комментария является краткое описание того элемента, к которому этот комментарий относится.

Никакие два члена или конструктора в одном классе или интерфейсе не должны иметь одинаковое краткое описание.

При документировании обобщенного типа или метода убедитесь, что вы документируете все параметры.

При документировании типа перечисления убедитесь, что вы документируете константы.

При документировании типа аннотации убедитесь, что вы документируете все члены.

Документирующие комментарии уровня пакета следует помещать в файл c именем `package-info.java`.

Является ли класс безопасным с точки зрения многопоточности или нет - в любом случае уровень его безопасности с точки
зрения потоков должен быть документирован(Item). Если класс сериализуется, нужно документировать сериализованный тип(
Item).

# 9. Общие вопросы программирования

## 9.1 Минимизируйте область видимости локальных переменных (Item 57)

Наиболее мощный способ минимизировать область видимости локальной переменной заключается в её объявлении там, где она
впервые используются.

Почти каждое объявление локальной переменной должно содержать инициализатор.

Следует предпочитать цикл `for` циклу `while` при условии, что после завершения цикла содержимое переменной цикла не
требуется.

Так же для уменьшения области видимости локальных переменных, заключается в сохранении малого размера и точной
направленности методов.

## 9.2 Предпочитайте циклы for для коллекции традиционным циклам for (Item 58)

Идиомы обхода коллекции или массива с использованием `for`:

```java
class ForIdiom {
    public static void main(String[] args) {

        // Классическая идиома обхода с использованием переменной для индекса
        for (int i = 0, n = expensiveComputation(); i < n; i++) {
        }

        // Идиома обхода в случае необходимости доступа к итератору
        for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
        }

        // Предпочтительная идиома обхода коллекции
        for (Element e : c) {
        }
    }
}

```

Минус первых двух идиом:

- Итераторы и индексные переменные создают лишние помехи - для работы нужны только сами элементы
- Итераторы в цикле встречаются 3 раза, а индексная переменная 4 раза. Можно использовать неверную переменную
- Излишние обращают внимание на тип контейнера и создают сложности при изменении типа

Когда нельзя применить цикл по коллекциям:

- **Деструктивная фильтрация** - если нужно удалить элемент из коллекции, то нужно использовать явный итератор. Начиная
  с Java 8 можно попробовать метод метод `removeIf`
- **Преобразования** - если требует заменить элементы, то нужно использовать итератор или индекс массива
- **Параллельное итерирование** - если нужен параллельный обход нескольких коллекций, требуется явное управление
  итератором или индексной переменной

## 9.3 Изучите и используйте возможности библиотек (Item 59)

Преимущества использования библиотек:

- Вместе со стандартной библиотекой вы используете знания написавших её экспертов, а также опыт тех, кто работал с ней
  до вас
- Не нужно терять время на написание решений для разовых задач, имеющих лишь косвенное отношение к вашей работе
- Производительность имеет тенденцию со временем повышаться, причем без каких-либо усилий с вашей стороны

**Не изобретайте велосипед!**

С каждой новой версией в библиотеки включается множество новых функций, и стоит быть в курсе всех новшеств.

Каждый программист должен знать основные возможности пакетов `java.lang`, `java.util`, `java.io`, а также их
подпакетов. А также библиотеки для многопоточности `java.util.concurrent`.

## 9.4 Если вам нужны точные ответы, избегайте float и double (Item 60)

Для вычисления, требующих точного результата, в том числе и для финансовых, не используйте типы с плавающей точкой -
`float` и `double`.

Как альтернатива класс `BigDecimal`(18+ цифр): отслеживает положение десятичной точки, полный контроль над
округлением (можно выбрать режим).

Если требуется большая производительность и не пугает самостоятельное отслеживание десятичной точки, а обрабатываемые
значения не слишком велики можно использовать `int`(<=9 цифр) и `long`(<=18 цифр).

## 9.5 Предпочитайте примитивные типы упакованных примитивным типам (Item 61)

В Java переменные бывают двух типов: примитивные(`int`, `double`, `boolean` и др.) и ссылочные(`String`, `List` и др.).
Для каждого примитивного типа есть аналог ссылочного типа, например `int` - `Integer`. Данные классы называются -
упакованные примитивные типы.

Основные различия примитивных и упакованных типов:

- У примитивных типов есть только значения, а у упакованных ещё и идентичность
- Примитивные типы имеют только полнофункциональные значения, а упакованные могут иметь нефункциональные - `null`
- Примитивные типы эффективны с точки зрения потребления памяти и времени работы, чем упакованные

Применение оператора `==` к упакованным примитивным типа почти всегда ошибочно, лучше сравнивать через `equals`.

При смешивании обычных и упакованных примитивных типов в одной операции - упакованных примитивный типа автоматически
распаковывается. Если объект нулевой(`null`), то возможно сгенерируется исключение `NullPointerException`. Также из-за
распаковки, может снижаться производительность.

Когда использовать упакованные типы:

- В качестве элементов, ключей и значений коллекций
- В качестве параметров типа в параметризованных типах(Item)
- При вызове рефлективных методов(Item)

## 9.6 Избегайте применения строк там, где уместнее другой тип (Item 62)

Класс `String` предназначен для представления текста.

Когда его не следует применять:

- `String` - плохая замена другим типам значений. При парсинге лучше сразу преобразовать в нужный тип
- `String` - плохая замена для перечислений(Item)
- `String` - плохая замена для агрегатных типов. Например, `String key = className + "#" + i.next();`
- `String` - плохая замена надежным (устойчивым к подделке) ключам

## 9.7 Помните о проблемах производительности при конкатенации строк (Item 63)

Время, которое необходимо оператору конкатенации для последовательного объединения n объектов `String`, пропорционально
квадрату n. Это следует из-за неизменяемого класса(Item).

Низкая производительность при объединении большого количеств строк:

```java
class Concatenation {
    // Inappropriate use of string concatenation - Performs horribly!
    public String statement() {
        String result = "";
        for (int i = 0; i < numItems(); i++) result += lineForItem(i);
        return result;
    }
}

```    

Применение StringBuilder для повышения производительности:

```java
class Concatenation {
    public String statement() {
        StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
        for (int i = 0; i < numItems(); i++) b.append(lineForItem(i));
        return b.toString();
    }
}

```

## 9.8 Для ссылки на объекты используйте их интерфейсы (Item 64)

Если имеются подходящие типы интерфейсов, то параметры, возвращаемые значения, переменные и поля следует объявлять,
используя типы интерфейсов.

```java
// Bad - uses class as type!
ArraysList<Son> subscribers=new ArraysList<>();

// Good - uses interface as type
        List<Son> subscribers=new ArraysList<>();
```

Если вы выработаете привычку использовать в качестве типов интерфейсы, ваша программа будет более гибкой.

Можно изменить объект не меняя переменную:

```java
List<Son> subscribers=new LinkedList<>();
```

Если исходная реализация интерфейса предлагала некоторую особенную функциональность, не предусмотренную общим контрактом
этого интерфейса, а код зависел от этой функциональности, крайне важно, чтобы новая реализация интерфейса обеспечивала
ту же функциональность.

Вполне допустимо ссылаться на объект с использованием класса, а не интерфейса, если подходящий интерфейс отсутствует:

- Классы значений: String, BigInteger и др.
- Классы фреймворков
- Если класс, реализующий интерфейс, предоставляет дополнительные методы, которых нет в интерфейсе

## 9.9 Для ссылки на объекты используйте их интерфейсы (Item 65)

